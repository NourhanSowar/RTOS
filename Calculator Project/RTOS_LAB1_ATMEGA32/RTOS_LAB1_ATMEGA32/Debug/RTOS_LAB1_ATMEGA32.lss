
RTOS_LAB1_ATMEGA32.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f7e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000034  00800060  00000f7e  00001012  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000064c  00800094  00800094  00001046  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001046  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001078  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000238  00000000  00000000  000010b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000296f  00000000  00000000  000012ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ec5  00000000  00000000  00003c5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000164e  00000000  00000000  00004b20  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005cc  00000000  00000000  00006170  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d73  00000000  00000000  0000673c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001c4f  00000000  00000000  000074af  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000208  00000000  00000000  000090fe  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 90 02 	jmp	0x520	; 0x520 <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ee e7       	ldi	r30, 0x7E	; 126
  68:	ff e0       	ldi	r31, 0x0F	; 15
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 39       	cpi	r26, 0x94	; 148
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	26 e0       	ldi	r18, 0x06	; 6
  78:	a4 e9       	ldi	r26, 0x94	; 148
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a0 3e       	cpi	r26, 0xE0	; 224
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 b4 02 	call	0x568	; 0x568 <main>
  8a:	0c 94 bd 07 	jmp	0xf7a	; 0xf7a <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  92:	cf 93       	push	r28
  94:	df 93       	push	r29
  96:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
  98:	0e 94 46 05 	call	0xa8c	; 0xa8c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
  9c:	20 91 94 00 	lds	r18, 0x0094	; 0x800094 <__data_end>
  a0:	30 91 95 00 	lds	r19, 0x0095	; 0x800095 <__data_end+0x1>
  a4:	c9 01       	movw	r24, r18
  a6:	8c 0f       	add	r24, r28
  a8:	9d 1f       	adc	r25, r29
  aa:	8c 3d       	cpi	r24, 0xDC	; 220
  ac:	45 e0       	ldi	r20, 0x05	; 5
  ae:	94 07       	cpc	r25, r20
  b0:	58 f4       	brcc	.+22     	; 0xc8 <pvPortMalloc+0x36>
  b2:	28 17       	cp	r18, r24
  b4:	39 07       	cpc	r19, r25
  b6:	58 f4       	brcc	.+22     	; 0xce <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
  b8:	e9 01       	movw	r28, r18
  ba:	ca 56       	subi	r28, 0x6A	; 106
  bc:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
  be:	90 93 95 00 	sts	0x0095, r25	; 0x800095 <__data_end+0x1>
  c2:	80 93 94 00 	sts	0x0094, r24	; 0x800094 <__data_end>
  c6:	05 c0       	rjmp	.+10     	; 0xd2 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
  c8:	c0 e0       	ldi	r28, 0x00	; 0
  ca:	d0 e0       	ldi	r29, 0x00	; 0
  cc:	02 c0       	rjmp	.+4      	; 0xd2 <pvPortMalloc+0x40>
  ce:	c0 e0       	ldi	r28, 0x00	; 0
  d0:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
  d2:	0e 94 1a 06 	call	0xc34	; 0xc34 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
  d6:	ce 01       	movw	r24, r28
  d8:	df 91       	pop	r29
  da:	cf 91       	pop	r28
  dc:	08 95       	ret

000000de <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  de:	08 95       	ret

000000e0 <enableTrigger>:
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{

	CLR_BIT(PORTB,2);
  e0:	c2 98       	cbi	0x18, 2	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  e2:	89 ef       	ldi	r24, 0xF9	; 249
  e4:	90 e0       	ldi	r25, 0x00	; 0
  e6:	01 97       	sbiw	r24, 0x01	; 1
  e8:	f1 f7       	brne	.-4      	; 0xe6 <enableTrigger+0x6>
  ea:	00 c0       	rjmp	.+0      	; 0xec <enableTrigger+0xc>
  ec:	00 00       	nop
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
  ee:	c2 9a       	sbi	0x18, 2	; 24
  f0:	8b ed       	ldi	r24, 0xDB	; 219
  f2:	95 e0       	ldi	r25, 0x05	; 5
  f4:	01 97       	sbiw	r24, 0x01	; 1
  f6:	f1 f7       	brne	.-4      	; 0xf4 <enableTrigger+0x14>
  f8:	00 c0       	rjmp	.+0      	; 0xfa <enableTrigger+0x1a>
  fa:	00 00       	nop
  fc:	08 95       	ret

000000fe <lcd_sendCommand>:
		
}


void lcd_sendCommand(unsigned char cmd)
{
  fe:	cf 93       	push	r28
 100:	c8 2f       	mov	r28, r24
	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);

	CLR_BIT(PORTB,0); // to enable command mode 
 102:	c0 98       	cbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // write signal to lcd 
 104:	c1 98       	cbi	0x18, 1	; 24

	PORTB &=0x0f;
 106:	88 b3       	in	r24, 0x18	; 24
 108:	8f 70       	andi	r24, 0x0F	; 15
 10a:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble command  
 10c:	88 b3       	in	r24, 0x18	; 24
 10e:	9c 2f       	mov	r25, r28
 110:	90 7f       	andi	r25, 0xF0	; 240
 112:	89 2b       	or	r24, r25
 114:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
 116:	0e 94 70 00 	call	0xe0	; 0xe0 <enableTrigger>

	PORTB &=0x0f;
 11a:	88 b3       	in	r24, 0x18	; 24
 11c:	8f 70       	andi	r24, 0x0F	; 15
 11e:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble command 
 120:	88 b3       	in	r24, 0x18	; 24
 122:	c2 95       	swap	r28
 124:	c0 7f       	andi	r28, 0xF0	; 240
 126:	c8 2b       	or	r28, r24
 128:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
 12a:	0e 94 70 00 	call	0xe0	; 0xe0 <enableTrigger>

}
 12e:	cf 91       	pop	r28
 130:	08 95       	ret

00000132 <lcd_init>:
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{

	DDRB=0xff; // init port B as O/P port 
 132:	8f ef       	ldi	r24, 0xFF	; 255
 134:	87 bb       	out	0x17, r24	; 23
	PORTB=0x04; // activate LCD enable 
 136:	84 e0       	ldi	r24, 0x04	; 4
 138:	88 bb       	out	0x18, r24	; 24

	lcd_sendCommand(0x33); // 4-bit mode 
 13a:	83 e3       	ldi	r24, 0x33	; 51
 13c:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
	lcd_sendCommand (0x32);
 140:	82 e3       	ldi	r24, 0x32	; 50
 142:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
	lcd_sendCommand (0x28);
 146:	88 e2       	ldi	r24, 0x28	; 40
 148:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
 14c:	8c e0       	ldi	r24, 0x0C	; 12
 14e:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
 152:	08 95       	ret

00000154 <lcd_displayChar>:
	enableTrigger();

}

void lcd_displayChar (unsigned char data)
{
 154:	cf 93       	push	r28
 156:	c8 2f       	mov	r28, r24

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
 158:	c0 9a       	sbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // activate lcd write 
 15a:	c1 98       	cbi	0x18, 1	; 24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
 15c:	88 b3       	in	r24, 0x18	; 24
 15e:	8f 70       	andi	r24, 0x0F	; 15
 160:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble data  
 162:	88 b3       	in	r24, 0x18	; 24
 164:	9c 2f       	mov	r25, r28
 166:	90 7f       	andi	r25, 0xF0	; 240
 168:	89 2b       	or	r24, r25
 16a:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
 16c:	0e 94 70 00 	call	0xe0	; 0xe0 <enableTrigger>
	
	PORTB &=0x0f;
 170:	88 b3       	in	r24, 0x18	; 24
 172:	8f 70       	andi	r24, 0x0F	; 15
 174:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble data 
 176:	88 b3       	in	r24, 0x18	; 24
 178:	c2 95       	swap	r28
 17a:	c0 7f       	andi	r28, 0xF0	; 240
 17c:	c8 2b       	or	r28, r24
 17e:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
 180:	0e 94 70 00 	call	0xe0	; 0xe0 <enableTrigger>
	
}
 184:	cf 91       	pop	r28
 186:	08 95       	ret

00000188 <lcd_gotoxy>:

void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
	 
	switch(y)
 188:	81 30       	cpi	r24, 0x01	; 1
 18a:	49 f0       	breq	.+18     	; 0x19e <lcd_gotoxy+0x16>
 18c:	28 f0       	brcs	.+10     	; 0x198 <lcd_gotoxy+0x10>
 18e:	82 30       	cpi	r24, 0x02	; 2
 190:	49 f0       	breq	.+18     	; 0x1a4 <lcd_gotoxy+0x1c>
 192:	83 30       	cpi	r24, 0x03	; 3
 194:	51 f0       	breq	.+20     	; 0x1aa <lcd_gotoxy+0x22>
 196:	0c c0       	rjmp	.+24     	; 0x1b0 <lcd_gotoxy+0x28>
	{
		case 0:

			position=position+x;
 198:	80 e8       	ldi	r24, 0x80	; 128
 19a:	86 0f       	add	r24, r22
					
		break;
 19c:	0a c0       	rjmp	.+20     	; 0x1b2 <lcd_gotoxy+0x2a>

		case 1:

			position=0xc0;
			position=position+x;
 19e:	80 ec       	ldi	r24, 0xC0	; 192
 1a0:	86 0f       	add	r24, r22

		break;
 1a2:	07 c0       	rjmp	.+14     	; 0x1b2 <lcd_gotoxy+0x2a>

		case 2:

			position=position+x;
 1a4:	80 e8       	ldi	r24, 0x80	; 128
 1a6:	86 0f       	add	r24, r22

		break;
 1a8:	04 c0       	rjmp	.+8      	; 0x1b2 <lcd_gotoxy+0x2a>

		case 3:
			position=position+x;
 1aa:	80 e8       	ldi	r24, 0x80	; 128
 1ac:	86 0f       	add	r24, r22
		break;
 1ae:	01 c0       	rjmp	.+2      	; 0x1b2 <lcd_gotoxy+0x2a>
}


void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
 1b0:	80 e8       	ldi	r24, 0x80	; 128
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
 1b2:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
 1b6:	08 95       	ret

000001b8 <lcd_clrScreen>:


void lcd_clrScreen(void)
{

	lcd_sendCommand(0x01);
 1b8:	81 e0       	ldi	r24, 0x01	; 1
 1ba:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
 1be:	08 95       	ret

000001c0 <lcd_dispString>:

}


void lcd_dispString(char * ptr)
{
 1c0:	cf 93       	push	r28
 1c2:	df 93       	push	r29
 1c4:	ec 01       	movw	r28, r24

	while(* ptr!= '\0')
 1c6:	88 81       	ld	r24, Y
 1c8:	88 23       	and	r24, r24
 1ca:	31 f0       	breq	.+12     	; 0x1d8 <lcd_dispString+0x18>
 1cc:	21 96       	adiw	r28, 0x01	; 1
	{
		lcd_displayChar(* ptr);
 1ce:	0e 94 aa 00 	call	0x154	; 0x154 <lcd_displayChar>


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
 1d2:	89 91       	ld	r24, Y+
 1d4:	81 11       	cpse	r24, r1
 1d6:	fb cf       	rjmp	.-10     	; 0x1ce <lcd_dispString+0xe>
	
	}



}
 1d8:	df 91       	pop	r29
 1da:	cf 91       	pop	r28
 1dc:	08 95       	ret

000001de <lcd_disp_string_xy>:

void lcd_disp_string_xy(char * ptr , int y , int x)
{
 1de:	cf 93       	push	r28
 1e0:	df 93       	push	r29
 1e2:	ec 01       	movw	r28, r24
 1e4:	86 2f       	mov	r24, r22

	lcd_gotoxy(y,x);
 1e6:	64 2f       	mov	r22, r20
 1e8:	0e 94 c4 00 	call	0x188	; 0x188 <lcd_gotoxy>
	lcd_dispString(ptr);
 1ec:	ce 01       	movw	r24, r28
 1ee:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <lcd_dispString>


}
 1f2:	df 91       	pop	r29
 1f4:	cf 91       	pop	r28
 1f6:	08 95       	ret

000001f8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 1f8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 1fa:	03 96       	adiw	r24, 0x03	; 3
 1fc:	92 83       	std	Z+2, r25	; 0x02
 1fe:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 200:	2f ef       	ldi	r18, 0xFF	; 255
 202:	3f ef       	ldi	r19, 0xFF	; 255
 204:	34 83       	std	Z+4, r19	; 0x04
 206:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 208:	96 83       	std	Z+6, r25	; 0x06
 20a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 20c:	90 87       	std	Z+8, r25	; 0x08
 20e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 210:	10 82       	st	Z, r1
 212:	08 95       	ret

00000214 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 214:	fc 01       	movw	r30, r24
 216:	11 86       	std	Z+9, r1	; 0x09
 218:	10 86       	std	Z+8, r1	; 0x08
 21a:	08 95       	ret

0000021c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 21c:	cf 93       	push	r28
 21e:	df 93       	push	r29
 220:	fc 01       	movw	r30, r24
 222:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 224:	21 81       	ldd	r18, Z+1	; 0x01
 226:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
 228:	e9 01       	movw	r28, r18
 22a:	8a 81       	ldd	r24, Y+2	; 0x02
 22c:	9b 81       	ldd	r25, Y+3	; 0x03
 22e:	13 96       	adiw	r26, 0x03	; 3
 230:	9c 93       	st	X, r25
 232:	8e 93       	st	-X, r24
 234:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
 236:	81 81       	ldd	r24, Z+1	; 0x01
 238:	92 81       	ldd	r25, Z+2	; 0x02
 23a:	15 96       	adiw	r26, 0x05	; 5
 23c:	9c 93       	st	X, r25
 23e:	8e 93       	st	-X, r24
 240:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 242:	8a 81       	ldd	r24, Y+2	; 0x02
 244:	9b 81       	ldd	r25, Y+3	; 0x03
 246:	ec 01       	movw	r28, r24
 248:	7d 83       	std	Y+5, r23	; 0x05
 24a:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 24c:	e9 01       	movw	r28, r18
 24e:	7b 83       	std	Y+3, r23	; 0x03
 250:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 252:	72 83       	std	Z+2, r23	; 0x02
 254:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 256:	19 96       	adiw	r26, 0x09	; 9
 258:	fc 93       	st	X, r31
 25a:	ee 93       	st	-X, r30
 25c:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
 25e:	80 81       	ld	r24, Z
 260:	8f 5f       	subi	r24, 0xFF	; 255
 262:	80 83       	st	Z, r24
}
 264:	df 91       	pop	r29
 266:	cf 91       	pop	r28
 268:	08 95       	ret

0000026a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 26a:	cf 93       	push	r28
 26c:	df 93       	push	r29
 26e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 270:	48 81       	ld	r20, Y
 272:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 274:	4f 3f       	cpi	r20, 0xFF	; 255
 276:	2f ef       	ldi	r18, 0xFF	; 255
 278:	52 07       	cpc	r21, r18
 27a:	31 f4       	brne	.+12     	; 0x288 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 27c:	dc 01       	movw	r26, r24
 27e:	17 96       	adiw	r26, 0x07	; 7
 280:	ed 91       	ld	r30, X+
 282:	fc 91       	ld	r31, X
 284:	18 97       	sbiw	r26, 0x08	; 8
 286:	17 c0       	rjmp	.+46     	; 0x2b6 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 288:	fc 01       	movw	r30, r24
 28a:	33 96       	adiw	r30, 0x03	; 3
 28c:	dc 01       	movw	r26, r24
 28e:	15 96       	adiw	r26, 0x05	; 5
 290:	2d 91       	ld	r18, X+
 292:	3c 91       	ld	r19, X
 294:	16 97       	sbiw	r26, 0x06	; 6
 296:	d9 01       	movw	r26, r18
 298:	2d 91       	ld	r18, X+
 29a:	3c 91       	ld	r19, X
 29c:	42 17       	cp	r20, r18
 29e:	53 07       	cpc	r21, r19
 2a0:	50 f0       	brcs	.+20     	; 0x2b6 <vListInsert+0x4c>
 2a2:	02 80       	ldd	r0, Z+2	; 0x02
 2a4:	f3 81       	ldd	r31, Z+3	; 0x03
 2a6:	e0 2d       	mov	r30, r0
 2a8:	a2 81       	ldd	r26, Z+2	; 0x02
 2aa:	b3 81       	ldd	r27, Z+3	; 0x03
 2ac:	2d 91       	ld	r18, X+
 2ae:	3c 91       	ld	r19, X
 2b0:	42 17       	cp	r20, r18
 2b2:	53 07       	cpc	r21, r19
 2b4:	b0 f7       	brcc	.-20     	; 0x2a2 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 2b6:	a2 81       	ldd	r26, Z+2	; 0x02
 2b8:	b3 81       	ldd	r27, Z+3	; 0x03
 2ba:	bb 83       	std	Y+3, r27	; 0x03
 2bc:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 2be:	15 96       	adiw	r26, 0x05	; 5
 2c0:	dc 93       	st	X, r29
 2c2:	ce 93       	st	-X, r28
 2c4:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
 2c6:	fd 83       	std	Y+5, r31	; 0x05
 2c8:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 2ca:	d3 83       	std	Z+3, r29	; 0x03
 2cc:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 2ce:	99 87       	std	Y+9, r25	; 0x09
 2d0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 2d2:	fc 01       	movw	r30, r24
 2d4:	20 81       	ld	r18, Z
 2d6:	2f 5f       	subi	r18, 0xFF	; 255
 2d8:	20 83       	st	Z, r18
}
 2da:	df 91       	pop	r29
 2dc:	cf 91       	pop	r28
 2de:	08 95       	ret

000002e0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 2e0:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 2e2:	a2 81       	ldd	r26, Z+2	; 0x02
 2e4:	b3 81       	ldd	r27, Z+3	; 0x03
 2e6:	84 81       	ldd	r24, Z+4	; 0x04
 2e8:	95 81       	ldd	r25, Z+5	; 0x05
 2ea:	15 96       	adiw	r26, 0x05	; 5
 2ec:	9c 93       	st	X, r25
 2ee:	8e 93       	st	-X, r24
 2f0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 2f2:	a4 81       	ldd	r26, Z+4	; 0x04
 2f4:	b5 81       	ldd	r27, Z+5	; 0x05
 2f6:	82 81       	ldd	r24, Z+2	; 0x02
 2f8:	93 81       	ldd	r25, Z+3	; 0x03
 2fa:	13 96       	adiw	r26, 0x03	; 3
 2fc:	9c 93       	st	X, r25
 2fe:	8e 93       	st	-X, r24
 300:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 302:	a0 85       	ldd	r26, Z+8	; 0x08
 304:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 306:	11 96       	adiw	r26, 0x01	; 1
 308:	8d 91       	ld	r24, X+
 30a:	9c 91       	ld	r25, X
 30c:	12 97       	sbiw	r26, 0x02	; 2
 30e:	e8 17       	cp	r30, r24
 310:	f9 07       	cpc	r31, r25
 312:	31 f4       	brne	.+12     	; 0x320 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 314:	84 81       	ldd	r24, Z+4	; 0x04
 316:	95 81       	ldd	r25, Z+5	; 0x05
 318:	12 96       	adiw	r26, 0x02	; 2
 31a:	9c 93       	st	X, r25
 31c:	8e 93       	st	-X, r24
 31e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
 320:	11 86       	std	Z+9, r1	; 0x09
 322:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 324:	8c 91       	ld	r24, X
 326:	81 50       	subi	r24, 0x01	; 1
 328:	8c 93       	st	X, r24
 32a:	08 95       	ret

0000032c <pxPortInitialiseStack>:
	portSAVE_CONTEXT();
	vTaskIncrementTick();
	vTaskSwitchContext();
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
 32c:	31 e1       	ldi	r19, 0x11	; 17
 32e:	fc 01       	movw	r30, r24
 330:	30 83       	st	Z, r19
 332:	31 97       	sbiw	r30, 0x01	; 1
 334:	22 e2       	ldi	r18, 0x22	; 34
 336:	20 83       	st	Z, r18
 338:	31 97       	sbiw	r30, 0x01	; 1
 33a:	a3 e3       	ldi	r26, 0x33	; 51
 33c:	a0 83       	st	Z, r26
 33e:	31 97       	sbiw	r30, 0x01	; 1
 340:	60 83       	st	Z, r22
 342:	31 97       	sbiw	r30, 0x01	; 1
 344:	70 83       	st	Z, r23
 346:	31 97       	sbiw	r30, 0x01	; 1
 348:	10 82       	st	Z, r1
 34a:	31 97       	sbiw	r30, 0x01	; 1
 34c:	60 e8       	ldi	r22, 0x80	; 128
 34e:	60 83       	st	Z, r22
 350:	31 97       	sbiw	r30, 0x01	; 1
 352:	10 82       	st	Z, r1
 354:	31 97       	sbiw	r30, 0x01	; 1
 356:	62 e0       	ldi	r22, 0x02	; 2
 358:	60 83       	st	Z, r22
 35a:	31 97       	sbiw	r30, 0x01	; 1
 35c:	63 e0       	ldi	r22, 0x03	; 3
 35e:	60 83       	st	Z, r22
 360:	31 97       	sbiw	r30, 0x01	; 1
 362:	64 e0       	ldi	r22, 0x04	; 4
 364:	60 83       	st	Z, r22
 366:	31 97       	sbiw	r30, 0x01	; 1
 368:	65 e0       	ldi	r22, 0x05	; 5
 36a:	60 83       	st	Z, r22
 36c:	31 97       	sbiw	r30, 0x01	; 1
 36e:	66 e0       	ldi	r22, 0x06	; 6
 370:	60 83       	st	Z, r22
 372:	31 97       	sbiw	r30, 0x01	; 1
 374:	67 e0       	ldi	r22, 0x07	; 7
 376:	60 83       	st	Z, r22
 378:	31 97       	sbiw	r30, 0x01	; 1
 37a:	68 e0       	ldi	r22, 0x08	; 8
 37c:	60 83       	st	Z, r22
 37e:	31 97       	sbiw	r30, 0x01	; 1
 380:	69 e0       	ldi	r22, 0x09	; 9
 382:	60 83       	st	Z, r22
 384:	31 97       	sbiw	r30, 0x01	; 1
 386:	60 e1       	ldi	r22, 0x10	; 16
 388:	60 83       	st	Z, r22
 38a:	31 97       	sbiw	r30, 0x01	; 1
 38c:	30 83       	st	Z, r19
 38e:	31 97       	sbiw	r30, 0x01	; 1
 390:	32 e1       	ldi	r19, 0x12	; 18
 392:	30 83       	st	Z, r19
 394:	31 97       	sbiw	r30, 0x01	; 1
 396:	33 e1       	ldi	r19, 0x13	; 19
 398:	30 83       	st	Z, r19
 39a:	31 97       	sbiw	r30, 0x01	; 1
 39c:	34 e1       	ldi	r19, 0x14	; 20
 39e:	30 83       	st	Z, r19
 3a0:	31 97       	sbiw	r30, 0x01	; 1
 3a2:	35 e1       	ldi	r19, 0x15	; 21
 3a4:	30 83       	st	Z, r19
 3a6:	31 97       	sbiw	r30, 0x01	; 1
 3a8:	36 e1       	ldi	r19, 0x16	; 22
 3aa:	30 83       	st	Z, r19
 3ac:	31 97       	sbiw	r30, 0x01	; 1
 3ae:	37 e1       	ldi	r19, 0x17	; 23
 3b0:	30 83       	st	Z, r19
 3b2:	31 97       	sbiw	r30, 0x01	; 1
 3b4:	38 e1       	ldi	r19, 0x18	; 24
 3b6:	30 83       	st	Z, r19
 3b8:	31 97       	sbiw	r30, 0x01	; 1
 3ba:	39 e1       	ldi	r19, 0x19	; 25
 3bc:	30 83       	st	Z, r19
 3be:	31 97       	sbiw	r30, 0x01	; 1
 3c0:	30 e2       	ldi	r19, 0x20	; 32
 3c2:	30 83       	st	Z, r19
 3c4:	31 97       	sbiw	r30, 0x01	; 1
 3c6:	31 e2       	ldi	r19, 0x21	; 33
 3c8:	30 83       	st	Z, r19
 3ca:	31 97       	sbiw	r30, 0x01	; 1
 3cc:	20 83       	st	Z, r18
 3ce:	31 97       	sbiw	r30, 0x01	; 1
 3d0:	23 e2       	ldi	r18, 0x23	; 35
 3d2:	20 83       	st	Z, r18
 3d4:	31 97       	sbiw	r30, 0x01	; 1
 3d6:	40 83       	st	Z, r20
 3d8:	31 97       	sbiw	r30, 0x01	; 1
 3da:	50 83       	st	Z, r21
 3dc:	31 97       	sbiw	r30, 0x01	; 1
 3de:	26 e2       	ldi	r18, 0x26	; 38
 3e0:	20 83       	st	Z, r18
 3e2:	31 97       	sbiw	r30, 0x01	; 1
 3e4:	27 e2       	ldi	r18, 0x27	; 39
 3e6:	20 83       	st	Z, r18
 3e8:	31 97       	sbiw	r30, 0x01	; 1
 3ea:	28 e2       	ldi	r18, 0x28	; 40
 3ec:	20 83       	st	Z, r18
 3ee:	31 97       	sbiw	r30, 0x01	; 1
 3f0:	29 e2       	ldi	r18, 0x29	; 41
 3f2:	20 83       	st	Z, r18
 3f4:	31 97       	sbiw	r30, 0x01	; 1
 3f6:	20 e3       	ldi	r18, 0x30	; 48
 3f8:	20 83       	st	Z, r18
 3fa:	31 97       	sbiw	r30, 0x01	; 1
 3fc:	21 e3       	ldi	r18, 0x31	; 49
 3fe:	20 83       	st	Z, r18
 400:	86 97       	sbiw	r24, 0x26	; 38
 402:	08 95       	ret

00000404 <xPortStartScheduler>:
 404:	1b bc       	out	0x2b, r1	; 43
 406:	8c e7       	ldi	r24, 0x7C	; 124
 408:	8a bd       	out	0x2a, r24	; 42
 40a:	8b e0       	ldi	r24, 0x0B	; 11
 40c:	8e bd       	out	0x2e, r24	; 46
 40e:	89 b7       	in	r24, 0x39	; 57
 410:	80 61       	ori	r24, 0x10	; 16
 412:	89 bf       	out	0x39, r24	; 57
 414:	a0 91 d5 06 	lds	r26, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 418:	b0 91 d6 06 	lds	r27, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 41c:	cd 91       	ld	r28, X+
 41e:	cd bf       	out	0x3d, r28	; 61
 420:	dd 91       	ld	r29, X+
 422:	de bf       	out	0x3e, r29	; 62
 424:	ff 91       	pop	r31
 426:	ef 91       	pop	r30
 428:	df 91       	pop	r29
 42a:	cf 91       	pop	r28
 42c:	bf 91       	pop	r27
 42e:	af 91       	pop	r26
 430:	9f 91       	pop	r25
 432:	8f 91       	pop	r24
 434:	7f 91       	pop	r23
 436:	6f 91       	pop	r22
 438:	5f 91       	pop	r21
 43a:	4f 91       	pop	r20
 43c:	3f 91       	pop	r19
 43e:	2f 91       	pop	r18
 440:	1f 91       	pop	r17
 442:	0f 91       	pop	r16
 444:	ff 90       	pop	r15
 446:	ef 90       	pop	r14
 448:	df 90       	pop	r13
 44a:	cf 90       	pop	r12
 44c:	bf 90       	pop	r11
 44e:	af 90       	pop	r10
 450:	9f 90       	pop	r9
 452:	8f 90       	pop	r8
 454:	7f 90       	pop	r7
 456:	6f 90       	pop	r6
 458:	5f 90       	pop	r5
 45a:	4f 90       	pop	r4
 45c:	3f 90       	pop	r3
 45e:	2f 90       	pop	r2
 460:	1f 90       	pop	r1
 462:	0f 90       	pop	r0
 464:	0f be       	out	0x3f, r0	; 63
 466:	0f 90       	pop	r0
 468:	08 95       	ret
 46a:	81 e0       	ldi	r24, 0x01	; 1
 46c:	08 95       	ret

0000046e <vPortYield>:
 46e:	0f 92       	push	r0
 470:	0f b6       	in	r0, 0x3f	; 63
 472:	f8 94       	cli
 474:	0f 92       	push	r0
 476:	1f 92       	push	r1
 478:	11 24       	eor	r1, r1
 47a:	2f 92       	push	r2
 47c:	3f 92       	push	r3
 47e:	4f 92       	push	r4
 480:	5f 92       	push	r5
 482:	6f 92       	push	r6
 484:	7f 92       	push	r7
 486:	8f 92       	push	r8
 488:	9f 92       	push	r9
 48a:	af 92       	push	r10
 48c:	bf 92       	push	r11
 48e:	cf 92       	push	r12
 490:	df 92       	push	r13
 492:	ef 92       	push	r14
 494:	ff 92       	push	r15
 496:	0f 93       	push	r16
 498:	1f 93       	push	r17
 49a:	2f 93       	push	r18
 49c:	3f 93       	push	r19
 49e:	4f 93       	push	r20
 4a0:	5f 93       	push	r21
 4a2:	6f 93       	push	r22
 4a4:	7f 93       	push	r23
 4a6:	8f 93       	push	r24
 4a8:	9f 93       	push	r25
 4aa:	af 93       	push	r26
 4ac:	bf 93       	push	r27
 4ae:	cf 93       	push	r28
 4b0:	df 93       	push	r29
 4b2:	ef 93       	push	r30
 4b4:	ff 93       	push	r31
 4b6:	a0 91 d5 06 	lds	r26, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 4ba:	b0 91 d6 06 	lds	r27, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 4be:	0d b6       	in	r0, 0x3d	; 61
 4c0:	0d 92       	st	X+, r0
 4c2:	0e b6       	in	r0, 0x3e	; 62
 4c4:	0d 92       	st	X+, r0
 4c6:	0e 94 3b 07 	call	0xe76	; 0xe76 <vTaskSwitchContext>
 4ca:	a0 91 d5 06 	lds	r26, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 4ce:	b0 91 d6 06 	lds	r27, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 4d2:	cd 91       	ld	r28, X+
 4d4:	cd bf       	out	0x3d, r28	; 61
 4d6:	dd 91       	ld	r29, X+
 4d8:	de bf       	out	0x3e, r29	; 62
 4da:	ff 91       	pop	r31
 4dc:	ef 91       	pop	r30
 4de:	df 91       	pop	r29
 4e0:	cf 91       	pop	r28
 4e2:	bf 91       	pop	r27
 4e4:	af 91       	pop	r26
 4e6:	9f 91       	pop	r25
 4e8:	8f 91       	pop	r24
 4ea:	7f 91       	pop	r23
 4ec:	6f 91       	pop	r22
 4ee:	5f 91       	pop	r21
 4f0:	4f 91       	pop	r20
 4f2:	3f 91       	pop	r19
 4f4:	2f 91       	pop	r18
 4f6:	1f 91       	pop	r17
 4f8:	0f 91       	pop	r16
 4fa:	ff 90       	pop	r15
 4fc:	ef 90       	pop	r14
 4fe:	df 90       	pop	r13
 500:	cf 90       	pop	r12
 502:	bf 90       	pop	r11
 504:	af 90       	pop	r10
 506:	9f 90       	pop	r9
 508:	8f 90       	pop	r8
 50a:	7f 90       	pop	r7
 50c:	6f 90       	pop	r6
 50e:	5f 90       	pop	r5
 510:	4f 90       	pop	r4
 512:	3f 90       	pop	r3
 514:	2f 90       	pop	r2
 516:	1f 90       	pop	r1
 518:	0f 90       	pop	r0
 51a:	0f be       	out	0x3f, r0	; 63
 51c:	0f 90       	pop	r0
 51e:	08 95       	ret

00000520 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
 520:	1f 92       	push	r1
 522:	0f 92       	push	r0
 524:	0f b6       	in	r0, 0x3f	; 63
 526:	0f 92       	push	r0
 528:	11 24       	eor	r1, r1
 52a:	2f 93       	push	r18
 52c:	3f 93       	push	r19
 52e:	4f 93       	push	r20
 530:	5f 93       	push	r21
 532:	6f 93       	push	r22
 534:	7f 93       	push	r23
 536:	8f 93       	push	r24
 538:	9f 93       	push	r25
 53a:	af 93       	push	r26
 53c:	bf 93       	push	r27
 53e:	ef 93       	push	r30
 540:	ff 93       	push	r31
		vTaskIncrementTick();
 542:	0e 94 56 05 	call	0xaac	; 0xaac <vTaskIncrementTick>
	}
 546:	ff 91       	pop	r31
 548:	ef 91       	pop	r30
 54a:	bf 91       	pop	r27
 54c:	af 91       	pop	r26
 54e:	9f 91       	pop	r25
 550:	8f 91       	pop	r24
 552:	7f 91       	pop	r23
 554:	6f 91       	pop	r22
 556:	5f 91       	pop	r21
 558:	4f 91       	pop	r20
 55a:	3f 91       	pop	r19
 55c:	2f 91       	pop	r18
 55e:	0f 90       	pop	r0
 560:	0f be       	out	0x3f, r0	; 63
 562:	0f 90       	pop	r0
 564:	1f 90       	pop	r1
 566:	18 95       	reti

00000568 <main>:
				 
				 flag = 1;
			 }
		 }else
		 {
			 flag = 0;
 568:	af 92       	push	r10
 56a:	bf 92       	push	r11
 56c:	cf 92       	push	r12
 56e:	df 92       	push	r13
 570:	ef 92       	push	r14
 572:	ff 92       	push	r15
 574:	0f 93       	push	r16
 576:	0e 94 99 00 	call	0x132	; 0x132 <lcd_init>
 57a:	8f e0       	ldi	r24, 0x0F	; 15
 57c:	8a bb       	out	0x1a, r24	; 26
 57e:	9f ef       	ldi	r25, 0xFF	; 255
 580:	9b bb       	out	0x1b, r25	; 27
 582:	84 bb       	out	0x14, r24	; 20
 584:	8e ef       	ldi	r24, 0xFE	; 254
 586:	85 bb       	out	0x15, r24	; 21
 588:	a1 2c       	mov	r10, r1
 58a:	b1 2c       	mov	r11, r1
 58c:	c1 2c       	mov	r12, r1
 58e:	d1 2c       	mov	r13, r1
 590:	0f 2e       	mov	r0, r31
 592:	fd ed       	ldi	r31, 0xDD	; 221
 594:	ef 2e       	mov	r14, r31
 596:	f6 e0       	ldi	r31, 0x06	; 6
 598:	ff 2e       	mov	r15, r31
 59a:	f0 2d       	mov	r31, r0
 59c:	03 e0       	ldi	r16, 0x03	; 3
 59e:	21 e0       	ldi	r18, 0x01	; 1
 5a0:	30 e0       	ldi	r19, 0x00	; 0
 5a2:	44 e6       	ldi	r20, 0x64	; 100
 5a4:	50 e0       	ldi	r21, 0x00	; 0
 5a6:	62 e6       	ldi	r22, 0x62	; 98
 5a8:	70 e0       	ldi	r23, 0x00	; 0
 5aa:	88 e1       	ldi	r24, 0x18	; 24
 5ac:	93 e0       	ldi	r25, 0x03	; 3
 5ae:	0e 94 c9 03 	call	0x792	; 0x792 <xTaskGenericCreate>
 5b2:	0f 2e       	mov	r0, r31
 5b4:	f9 ed       	ldi	r31, 0xD9	; 217
 5b6:	ef 2e       	mov	r14, r31
 5b8:	f6 e0       	ldi	r31, 0x06	; 6
 5ba:	ff 2e       	mov	r15, r31
 5bc:	f0 2d       	mov	r31, r0
 5be:	01 e0       	ldi	r16, 0x01	; 1
 5c0:	20 e0       	ldi	r18, 0x00	; 0
 5c2:	30 e0       	ldi	r19, 0x00	; 0
 5c4:	48 ec       	ldi	r20, 0xC8	; 200
 5c6:	50 e0       	ldi	r21, 0x00	; 0
 5c8:	6d e6       	ldi	r22, 0x6D	; 109
 5ca:	70 e0       	ldi	r23, 0x00	; 0
 5cc:	81 e6       	ldi	r24, 0x61	; 97
 5ce:	93 e0       	ldi	r25, 0x03	; 3
 5d0:	0e 94 c9 03 	call	0x792	; 0x792 <xTaskGenericCreate>
 5d4:	0e 94 1b 05 	call	0xa36	; 0xa36 <vTaskStartScheduler>
 5d8:	80 e0       	ldi	r24, 0x00	; 0
 5da:	90 e0       	ldi	r25, 0x00	; 0
 5dc:	0f 91       	pop	r16
 5de:	ff 90       	pop	r15
 5e0:	ef 90       	pop	r14
 5e2:	df 90       	pop	r13
 5e4:	cf 90       	pop	r12
 5e6:	bf 90       	pop	r11
 5e8:	af 90       	pop	r10
 5ea:	08 95       	ret

000005ec <LcdWelcome>:
 
 // ----------------programmer layer --------------//

 void LcdWelcome(void )
 {
	 lcd_clrScreen();
 5ec:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <lcd_clrScreen>
	 lcd_disp_string_xy("Welcome" , 0 , i);
 5f0:	40 91 72 06 	lds	r20, 0x0672	; 0x800672 <i>
 5f4:	50 91 73 06 	lds	r21, 0x0673	; 0x800673 <i+0x1>
 5f8:	60 e0       	ldi	r22, 0x00	; 0
 5fa:	70 e0       	ldi	r23, 0x00	; 0
 5fc:	88 e7       	ldi	r24, 0x78	; 120
 5fe:	90 e0       	ldi	r25, 0x00	; 0
 600:	0e 94 ef 00 	call	0x1de	; 0x1de <lcd_disp_string_xy>
 604:	08 95       	ret

00000606 <LcdFlash>:
 }
 void LcdFlash(void)
 {
	 lcd_clrScreen();
 606:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <lcd_clrScreen>
	 lcd_disp_string_xy("press any key " , 0,0);
 60a:	40 e0       	ldi	r20, 0x00	; 0
 60c:	50 e0       	ldi	r21, 0x00	; 0
 60e:	60 e0       	ldi	r22, 0x00	; 0
 610:	70 e0       	ldi	r23, 0x00	; 0
 612:	80 e8       	ldi	r24, 0x80	; 128
 614:	90 e0       	ldi	r25, 0x00	; 0
 616:	0e 94 ef 00 	call	0x1de	; 0x1de <lcd_disp_string_xy>
	 vTaskDelay(500);
 61a:	84 ef       	ldi	r24, 0xF4	; 244
 61c:	91 e0       	ldi	r25, 0x01	; 1
 61e:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vTaskDelay>
	 lcd_clrScreen();
 622:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <lcd_clrScreen>
	 vTaskDelay(250);
 626:	8a ef       	ldi	r24, 0xFA	; 250
 628:	90 e0       	ldi	r25, 0x00	; 0
 62a:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vTaskDelay>
 62e:	08 95       	ret

00000630 <PeriodicTask>:
		return 0;
}
 
 /* ================Architecture layer======================= */
 void PeriodicTask(void * pvParameters )
 {
 630:	0f 93       	push	r16
 632:	1f 93       	push	r17
 634:	cf 93       	push	r28
 636:	df 93       	push	r29
 638:	00 d0       	rcall	.+0      	; 0x63a <PeriodicTask+0xa>
 63a:	cd b7       	in	r28, 0x3d	; 61
 63c:	de b7       	in	r29, 0x3e	; 62
 63e:	8c 01       	movw	r16, r24
	 long paramter ;
	 paramter = (long) pvParameters ;
	 portTickType LastTime = xTaskGetTickCount();
 640:	0e 94 4c 05 	call	0xa98	; 0xa98 <xTaskGetTickCount>
 644:	9a 83       	std	Y+2, r25	; 0x02
 646:	89 83       	std	Y+1, r24	; 0x01
	 char counter = 1;
	 if (paramter == 1)
 648:	01 30       	cpi	r16, 0x01	; 1
 64a:	11 05       	cpc	r17, r1
 64c:	41 f5       	brne	.+80     	; 0x69e <PeriodicTask+0x6e>
 64e:	11 e0       	ldi	r17, 0x01	; 1
		 while (1)
		 {
			 for (counter ; counter<=24 ; counter++) // 24 is to repeat 3 times right to left
			 {
				 
				 vTaskDelayUntil(&LastTime ,62.5);  // 62.5 is 1000 /16 where 8 is a number of digits on screen
 650:	6e e3       	ldi	r22, 0x3E	; 62
 652:	70 e0       	ldi	r23, 0x00	; 0
 654:	ce 01       	movw	r24, r28
 656:	01 96       	adiw	r24, 0x01	; 1
 658:	0e 94 9f 06 	call	0xd3e	; 0xd3e <vTaskDelayUntil>
				 LcdWelcome();
 65c:	0e 94 f6 02 	call	0x5ec	; 0x5ec <LcdWelcome>
				 i++;
 660:	80 91 72 06 	lds	r24, 0x0672	; 0x800672 <i>
 664:	90 91 73 06 	lds	r25, 0x0673	; 0x800673 <i+0x1>
 668:	01 96       	adiw	r24, 0x01	; 1
				 
				 if (i==8)
 66a:	88 30       	cpi	r24, 0x08	; 8
 66c:	91 05       	cpc	r25, r1
 66e:	29 f0       	breq	.+10     	; 0x67a <PeriodicTask+0x4a>
			 for (counter ; counter<=24 ; counter++) // 24 is to repeat 3 times right to left
			 {
				 
				 vTaskDelayUntil(&LastTime ,62.5);  // 62.5 is 1000 /16 where 8 is a number of digits on screen
				 LcdWelcome();
				 i++;
 670:	90 93 73 06 	sts	0x0673, r25	; 0x800673 <i+0x1>
 674:	80 93 72 06 	sts	0x0672, r24	; 0x800672 <i>
 678:	04 c0       	rjmp	.+8      	; 0x682 <PeriodicTask+0x52>
				 
				 if (i==8)
				 {
					 i=0;
 67a:	10 92 73 06 	sts	0x0673, r1	; 0x800673 <i+0x1>
 67e:	10 92 72 06 	sts	0x0672, r1	; 0x800672 <i>
				 }
				 if (counter==24)
 682:	18 31       	cpi	r17, 0x18	; 24
 684:	41 f4       	brne	.+16     	; 0x696 <PeriodicTask+0x66>
				 {
					 lcd_clrScreen();
 686:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <lcd_clrScreen>
					 LcdFlash();
 68a:	0e 94 03 03 	call	0x606	; 0x606 <LcdFlash>
					
					 vTaskDelay(10 );
 68e:	8a e0       	ldi	r24, 0x0A	; 10
 690:	90 e0       	ldi	r25, 0x00	; 0
 692:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vTaskDelay>
	 char counter = 1;
	 if (paramter == 1)
	 {
		 while (1)
		 {
			 for (counter ; counter<=24 ; counter++) // 24 is to repeat 3 times right to left
 696:	1f 5f       	subi	r17, 0xFF	; 255
 698:	19 31       	cpi	r17, 0x19	; 25
 69a:	d1 f6       	brne	.-76     	; 0x650 <PeriodicTask+0x20>
 69c:	ff cf       	rjmp	.-2      	; 0x69c <PeriodicTask+0x6c>
					// lcd_disp_string_xy("start" , 0,0); //error !
				 }	
			 }
		 } 
	 } 
	 vTaskDelete(NULL);
 69e:	80 e0       	ldi	r24, 0x00	; 0
 6a0:	90 e0       	ldi	r25, 0x00	; 0
 6a2:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vTaskDelete>
 }
 6a6:	0f 90       	pop	r0
 6a8:	0f 90       	pop	r0
 6aa:	df 91       	pop	r29
 6ac:	cf 91       	pop	r28
 6ae:	1f 91       	pop	r17
 6b0:	0f 91       	pop	r16
 6b2:	08 95       	ret

000006b4 <InitPWM>:
	 vTaskDelay(250);
 }
 
 void InitPWM()
 {
	 DDRD |= 0xFF ; 
 6b4:	81 b3       	in	r24, 0x11	; 17
 6b6:	8f ef       	ldi	r24, 0xFF	; 255
 6b8:	81 bb       	out	0x11, r24	; 17
	 TCCR2 |=(1<<WGM00)|(1<<WGM01)|(1<<COM01)|(1<<CS00);
 6ba:	85 b5       	in	r24, 0x25	; 37
 6bc:	89 66       	ori	r24, 0x69	; 105
 6be:	85 bd       	out	0x25, r24	; 37
 6c0:	08 95       	ret

000006c2 <BlinkingPatternTask>:
 }
 
 
void BlinkingPatternTask(void * pvParameters )
{
	InitPWM();
 6c2:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <InitPWM>
	portTickType LastTimeCounter = xTaskGetTickCount();
 6c6:	0e 94 4c 05 	call	0xa98	; 0xa98 <xTaskGetTickCount>
		/* first  rising Stage */
		 for (counter1 ; counter1<=154; counter1++) //154 is number to get 250 ms through to proteus run time  ,I notice that 250ms equals 4.17*10^3
		 { 
			  for(duty;duty<50;)
			  {
				OCR2 = duty ;
 6ca:	13 bc       	out	0x23, r1	; 35
 6cc:	8a e0       	ldi	r24, 0x0A	; 10
 6ce:	83 bd       	out	0x23, r24	; 35
 6d0:	84 e1       	ldi	r24, 0x14	; 20
 6d2:	83 bd       	out	0x23, r24	; 35
 6d4:	8e e1       	ldi	r24, 0x1E	; 30
 6d6:	83 bd       	out	0x23, r24	; 35
 6d8:	88 e2       	ldi	r24, 0x28	; 40
 6da:	83 bd       	out	0x23, r24	; 35
			  if (counter1==154)
			  {
				  OCR2 = 255;				  
			  }
			  /*high stage*/
			  OCR2 =255;
 6dc:	8f ef       	ldi	r24, 0xFF	; 255
 6de:	83 bd       	out	0x23, r24	; 35
 6e0:	2f e7       	ldi	r18, 0x7F	; 127
 6e2:	8a e1       	ldi	r24, 0x1A	; 26
 6e4:	96 e0       	ldi	r25, 0x06	; 6
 6e6:	21 50       	subi	r18, 0x01	; 1
 6e8:	80 40       	sbci	r24, 0x00	; 0
 6ea:	90 40       	sbci	r25, 0x00	; 0
 6ec:	e1 f7       	brne	.-8      	; 0x6e6 <BlinkingPatternTask+0x24>
 6ee:	00 c0       	rjmp	.+0      	; 0x6f0 <BlinkingPatternTask+0x2e>
 6f0:	00 00       	nop
 6f2:	2b e9       	ldi	r18, 0x9B	; 155
 6f4:	30 e0       	ldi	r19, 0x00	; 0
 6f6:	07 c0       	rjmp	.+14     	; 0x706 <BlinkingPatternTask+0x44>
			/*falling edge*/
			  for (counter2; counter2<=154; counter2++ )
			  {
				  for(duty=255;duty>0;)
				  {
					  OCR2 = duty ;
 6f8:	83 bd       	out	0x23, r24	; 35
 6fa:	8a 50       	subi	r24, 0x0A	; 10
			  OCR2 =255;
			  _delay_ms(250);
			/*falling edge*/
			  for (counter2; counter2<=154; counter2++ )
			  {
				  for(duty=255;duty>0;)
 6fc:	8b 3f       	cpi	r24, 0xFB	; 251
 6fe:	e1 f7       	brne	.-8      	; 0x6f8 <BlinkingPatternTask+0x36>
 700:	21 50       	subi	r18, 0x01	; 1
 702:	31 09       	sbc	r19, r1
			  }
			  /*high stage*/
			  OCR2 =255;
			  _delay_ms(250);
			/*falling edge*/
			  for (counter2; counter2<=154; counter2++ )
 704:	11 f0       	breq	.+4      	; 0x70a <BlinkingPatternTask+0x48>
	 vTaskDelete(NULL);
 }
 
 
void BlinkingPatternTask(void * pvParameters )
{
 706:	8f ef       	ldi	r24, 0xFF	; 255
 708:	f7 cf       	rjmp	.-18     	; 0x6f8 <BlinkingPatternTask+0x36>
				  }
			  }
			 
			  if (counter2>=154)
			  {
				 OCR2 =0;	 
 70a:	13 bc       	out	0x23, r1	; 35
			  }
			 /*low stage*/
			  OCR2 =0;
 70c:	13 bc       	out	0x23, r1	; 35
 70e:	2f e7       	ldi	r18, 0x7F	; 127
 710:	8a e1       	ldi	r24, 0x1A	; 26
 712:	96 e0       	ldi	r25, 0x06	; 6
 714:	21 50       	subi	r18, 0x01	; 1
 716:	80 40       	sbci	r24, 0x00	; 0
 718:	90 40       	sbci	r25, 0x00	; 0
 71a:	e1 f7       	brne	.-8      	; 0x714 <BlinkingPatternTask+0x52>
 71c:	00 c0       	rjmp	.+0      	; 0x71e <BlinkingPatternTask+0x5c>
 71e:	00 00       	nop
			 _delay_ms(250);
			  while (1)
			  {
				  PORTD = 0x00;
 720:	12 ba       	out	0x12, r1	; 18
 722:	fe cf       	rjmp	.-4      	; 0x720 <BlinkingPatternTask+0x5e>

00000724 <prvAddCurrentTaskToDelayedList>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
 724:	cf 93       	push	r28
 726:	df 93       	push	r29
 728:	ec 01       	movw	r28, r24
 72a:	e0 91 d5 06 	lds	r30, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 72e:	f0 91 d6 06 	lds	r31, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 732:	93 83       	std	Z+3, r25	; 0x03
 734:	82 83       	std	Z+2, r24	; 0x02
 736:	80 91 7c 06 	lds	r24, 0x067C	; 0x80067c <xTickCount>
 73a:	90 91 7d 06 	lds	r25, 0x067D	; 0x80067d <xTickCount+0x1>
 73e:	c8 17       	cp	r28, r24
 740:	d9 07       	cpc	r29, r25
 742:	68 f4       	brcc	.+26     	; 0x75e <prvAddCurrentTaskToDelayedList+0x3a>
 744:	60 91 d5 06 	lds	r22, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 748:	70 91 d6 06 	lds	r23, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 74c:	80 91 92 06 	lds	r24, 0x0692	; 0x800692 <pxOverflowDelayedTaskList>
 750:	90 91 93 06 	lds	r25, 0x0693	; 0x800693 <pxOverflowDelayedTaskList+0x1>
 754:	6e 5f       	subi	r22, 0xFE	; 254
 756:	7f 4f       	sbci	r23, 0xFF	; 255
 758:	0e 94 35 01 	call	0x26a	; 0x26a <vListInsert>
 75c:	17 c0       	rjmp	.+46     	; 0x78c <prvAddCurrentTaskToDelayedList+0x68>
 75e:	60 91 d5 06 	lds	r22, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 762:	70 91 d6 06 	lds	r23, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 766:	80 91 94 06 	lds	r24, 0x0694	; 0x800694 <pxDelayedTaskList>
 76a:	90 91 95 06 	lds	r25, 0x0695	; 0x800695 <pxDelayedTaskList+0x1>
 76e:	6e 5f       	subi	r22, 0xFE	; 254
 770:	7f 4f       	sbci	r23, 0xFF	; 255
 772:	0e 94 35 01 	call	0x26a	; 0x26a <vListInsert>
 776:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 77a:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 77e:	c8 17       	cp	r28, r24
 780:	d9 07       	cpc	r29, r25
 782:	20 f4       	brcc	.+8      	; 0x78c <prvAddCurrentTaskToDelayedList+0x68>
 784:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 788:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__DATA_REGION_ORIGIN__>
 78c:	df 91       	pop	r29
 78e:	cf 91       	pop	r28
 790:	08 95       	ret

00000792 <xTaskGenericCreate>:
 792:	4f 92       	push	r4
 794:	5f 92       	push	r5
 796:	6f 92       	push	r6
 798:	7f 92       	push	r7
 79a:	8f 92       	push	r8
 79c:	9f 92       	push	r9
 79e:	af 92       	push	r10
 7a0:	bf 92       	push	r11
 7a2:	cf 92       	push	r12
 7a4:	df 92       	push	r13
 7a6:	ef 92       	push	r14
 7a8:	ff 92       	push	r15
 7aa:	0f 93       	push	r16
 7ac:	1f 93       	push	r17
 7ae:	cf 93       	push	r28
 7b0:	df 93       	push	r29
 7b2:	5c 01       	movw	r10, r24
 7b4:	4b 01       	movw	r8, r22
 7b6:	ea 01       	movw	r28, r20
 7b8:	29 01       	movw	r4, r18
 7ba:	81 e2       	ldi	r24, 0x21	; 33
 7bc:	90 e0       	ldi	r25, 0x00	; 0
 7be:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
 7c2:	3c 01       	movw	r6, r24
 7c4:	00 97       	sbiw	r24, 0x00	; 0
 7c6:	09 f4       	brne	.+2      	; 0x7ca <xTaskGenericCreate+0x38>
 7c8:	db c0       	rjmp	.+438    	; 0x980 <__stack+0x121>
 7ca:	c1 14       	cp	r12, r1
 7cc:	d1 04       	cpc	r13, r1
 7ce:	09 f0       	breq	.+2      	; 0x7d2 <xTaskGenericCreate+0x40>
 7d0:	d2 c0       	rjmp	.+420    	; 0x976 <__stack+0x117>
 7d2:	ce 01       	movw	r24, r28
 7d4:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
 7d8:	f3 01       	movw	r30, r6
 7da:	90 8f       	std	Z+24, r25	; 0x18
 7dc:	87 8b       	std	Z+23, r24	; 0x17
 7de:	00 97       	sbiw	r24, 0x00	; 0
 7e0:	21 f4       	brne	.+8      	; 0x7ea <xTaskGenericCreate+0x58>
 7e2:	c3 01       	movw	r24, r6
 7e4:	0e 94 6f 00 	call	0xde	; 0xde <vPortFree>
 7e8:	cb c0       	rjmp	.+406    	; 0x980 <__stack+0x121>
 7ea:	ae 01       	movw	r20, r28
 7ec:	65 ea       	ldi	r22, 0xA5	; 165
 7ee:	70 e0       	ldi	r23, 0x00	; 0
 7f0:	0e 94 a7 07 	call	0xf4e	; 0xf4e <memset>
 7f4:	21 97       	sbiw	r28, 0x01	; 1
 7f6:	f3 01       	movw	r30, r6
 7f8:	87 89       	ldd	r24, Z+23	; 0x17
 7fa:	90 8d       	ldd	r25, Z+24	; 0x18
 7fc:	c8 0f       	add	r28, r24
 7fe:	d9 1f       	adc	r29, r25
 800:	48 e0       	ldi	r20, 0x08	; 8
 802:	50 e0       	ldi	r21, 0x00	; 0
 804:	b4 01       	movw	r22, r8
 806:	c3 01       	movw	r24, r6
 808:	49 96       	adiw	r24, 0x19	; 25
 80a:	0e 94 ae 07 	call	0xf5c	; 0xf5c <strncpy>
 80e:	f3 01       	movw	r30, r6
 810:	10 a2       	std	Z+32, r1	; 0x20
 812:	10 2f       	mov	r17, r16
 814:	05 30       	cpi	r16, 0x05	; 5
 816:	08 f0       	brcs	.+2      	; 0x81a <xTaskGenericCreate+0x88>
 818:	14 e0       	ldi	r17, 0x04	; 4
 81a:	f3 01       	movw	r30, r6
 81c:	16 8b       	std	Z+22, r17	; 0x16
 81e:	63 01       	movw	r12, r6
 820:	f2 e0       	ldi	r31, 0x02	; 2
 822:	cf 0e       	add	r12, r31
 824:	d1 1c       	adc	r13, r1
 826:	c6 01       	movw	r24, r12
 828:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialiseItem>
 82c:	c3 01       	movw	r24, r6
 82e:	0c 96       	adiw	r24, 0x0c	; 12
 830:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialiseItem>
 834:	f3 01       	movw	r30, r6
 836:	71 86       	std	Z+9, r7	; 0x09
 838:	60 86       	std	Z+8, r6	; 0x08
 83a:	85 e0       	ldi	r24, 0x05	; 5
 83c:	90 e0       	ldi	r25, 0x00	; 0
 83e:	81 1b       	sub	r24, r17
 840:	91 09       	sbc	r25, r1
 842:	95 87       	std	Z+13, r25	; 0x0d
 844:	84 87       	std	Z+12, r24	; 0x0c
 846:	73 8a       	std	Z+19, r7	; 0x13
 848:	62 8a       	std	Z+18, r6	; 0x12
 84a:	a2 01       	movw	r20, r4
 84c:	b5 01       	movw	r22, r10
 84e:	ce 01       	movw	r24, r28
 850:	0e 94 96 01 	call	0x32c	; 0x32c <pxPortInitialiseStack>
 854:	f3 01       	movw	r30, r6
 856:	91 83       	std	Z+1, r25	; 0x01
 858:	80 83       	st	Z, r24
 85a:	e1 14       	cp	r14, r1
 85c:	f1 04       	cpc	r15, r1
 85e:	19 f0       	breq	.+6      	; 0x866 <__stack+0x7>
 860:	f7 01       	movw	r30, r14
 862:	71 82       	std	Z+1, r7	; 0x01
 864:	60 82       	st	Z, r6
 866:	0f b6       	in	r0, 0x3f	; 63
 868:	f8 94       	cli
 86a:	0f 92       	push	r0
 86c:	80 91 7e 06 	lds	r24, 0x067E	; 0x80067e <uxCurrentNumberOfTasks>
 870:	8f 5f       	subi	r24, 0xFF	; 255
 872:	80 93 7e 06 	sts	0x067E, r24	; 0x80067e <uxCurrentNumberOfTasks>
 876:	80 91 d5 06 	lds	r24, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 87a:	90 91 d6 06 	lds	r25, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 87e:	89 2b       	or	r24, r25
 880:	a1 f5       	brne	.+104    	; 0x8ea <__stack+0x8b>
 882:	70 92 d6 06 	sts	0x06D6, r7	; 0x8006d6 <pxCurrentTCB+0x1>
 886:	60 92 d5 06 	sts	0x06D5, r6	; 0x8006d5 <pxCurrentTCB>
 88a:	80 91 7e 06 	lds	r24, 0x067E	; 0x80067e <uxCurrentNumberOfTasks>
 88e:	81 30       	cpi	r24, 0x01	; 1
 890:	d9 f5       	brne	.+118    	; 0x908 <__stack+0xa9>
 892:	c8 ea       	ldi	r28, 0xA8	; 168
 894:	d6 e0       	ldi	r29, 0x06	; 6
 896:	0f 2e       	mov	r0, r31
 898:	f5 ed       	ldi	r31, 0xD5	; 213
 89a:	ef 2e       	mov	r14, r31
 89c:	f6 e0       	ldi	r31, 0x06	; 6
 89e:	ff 2e       	mov	r15, r31
 8a0:	f0 2d       	mov	r31, r0
 8a2:	ce 01       	movw	r24, r28
 8a4:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
 8a8:	29 96       	adiw	r28, 0x09	; 9
 8aa:	ce 15       	cp	r28, r14
 8ac:	df 05       	cpc	r29, r15
 8ae:	c9 f7       	brne	.-14     	; 0x8a2 <__stack+0x43>
 8b0:	8f e9       	ldi	r24, 0x9F	; 159
 8b2:	96 e0       	ldi	r25, 0x06	; 6
 8b4:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
 8b8:	86 e9       	ldi	r24, 0x96	; 150
 8ba:	96 e0       	ldi	r25, 0x06	; 6
 8bc:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
 8c0:	89 e8       	ldi	r24, 0x89	; 137
 8c2:	96 e0       	ldi	r25, 0x06	; 6
 8c4:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
 8c8:	80 e8       	ldi	r24, 0x80	; 128
 8ca:	96 e0       	ldi	r25, 0x06	; 6
 8cc:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
 8d0:	8f e9       	ldi	r24, 0x9F	; 159
 8d2:	96 e0       	ldi	r25, 0x06	; 6
 8d4:	90 93 95 06 	sts	0x0695, r25	; 0x800695 <pxDelayedTaskList+0x1>
 8d8:	80 93 94 06 	sts	0x0694, r24	; 0x800694 <pxDelayedTaskList>
 8dc:	86 e9       	ldi	r24, 0x96	; 150
 8de:	96 e0       	ldi	r25, 0x06	; 6
 8e0:	90 93 93 06 	sts	0x0693, r25	; 0x800693 <pxOverflowDelayedTaskList+0x1>
 8e4:	80 93 92 06 	sts	0x0692, r24	; 0x800692 <pxOverflowDelayedTaskList>
 8e8:	0f c0       	rjmp	.+30     	; 0x908 <__stack+0xa9>
 8ea:	80 91 79 06 	lds	r24, 0x0679	; 0x800679 <xSchedulerRunning>
 8ee:	81 11       	cpse	r24, r1
 8f0:	0b c0       	rjmp	.+22     	; 0x908 <__stack+0xa9>
 8f2:	e0 91 d5 06 	lds	r30, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 8f6:	f0 91 d6 06 	lds	r31, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 8fa:	86 89       	ldd	r24, Z+22	; 0x16
 8fc:	08 17       	cp	r16, r24
 8fe:	20 f0       	brcs	.+8      	; 0x908 <__stack+0xa9>
 900:	70 92 d6 06 	sts	0x06D6, r7	; 0x8006d6 <pxCurrentTCB+0x1>
 904:	60 92 d5 06 	sts	0x06D5, r6	; 0x8006d5 <pxCurrentTCB>
 908:	f3 01       	movw	r30, r6
 90a:	86 89       	ldd	r24, Z+22	; 0x16
 90c:	90 91 7b 06 	lds	r25, 0x067B	; 0x80067b <uxTopUsedPriority>
 910:	98 17       	cp	r25, r24
 912:	10 f4       	brcc	.+4      	; 0x918 <__stack+0xb9>
 914:	80 93 7b 06 	sts	0x067B, r24	; 0x80067b <uxTopUsedPriority>
 918:	90 91 74 06 	lds	r25, 0x0674	; 0x800674 <uxTaskNumber>
 91c:	9f 5f       	subi	r25, 0xFF	; 255
 91e:	90 93 74 06 	sts	0x0674, r25	; 0x800674 <uxTaskNumber>
 922:	90 91 7a 06 	lds	r25, 0x067A	; 0x80067a <uxTopReadyPriority>
 926:	98 17       	cp	r25, r24
 928:	10 f4       	brcc	.+4      	; 0x92e <__stack+0xcf>
 92a:	80 93 7a 06 	sts	0x067A, r24	; 0x80067a <uxTopReadyPriority>
 92e:	90 e0       	ldi	r25, 0x00	; 0
 930:	9c 01       	movw	r18, r24
 932:	22 0f       	add	r18, r18
 934:	33 1f       	adc	r19, r19
 936:	22 0f       	add	r18, r18
 938:	33 1f       	adc	r19, r19
 93a:	22 0f       	add	r18, r18
 93c:	33 1f       	adc	r19, r19
 93e:	82 0f       	add	r24, r18
 940:	93 1f       	adc	r25, r19
 942:	b6 01       	movw	r22, r12
 944:	88 55       	subi	r24, 0x58	; 88
 946:	99 4f       	sbci	r25, 0xF9	; 249
 948:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>
 94c:	0f 90       	pop	r0
 94e:	0f be       	out	0x3f, r0	; 63
 950:	80 91 79 06 	lds	r24, 0x0679	; 0x800679 <xSchedulerRunning>
 954:	88 23       	and	r24, r24
 956:	59 f0       	breq	.+22     	; 0x96e <__stack+0x10f>
 958:	e0 91 d5 06 	lds	r30, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 95c:	f0 91 d6 06 	lds	r31, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 960:	86 89       	ldd	r24, Z+22	; 0x16
 962:	80 17       	cp	r24, r16
 964:	30 f4       	brcc	.+12     	; 0x972 <__stack+0x113>
 966:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
 96a:	81 e0       	ldi	r24, 0x01	; 1
 96c:	0a c0       	rjmp	.+20     	; 0x982 <__stack+0x123>
 96e:	81 e0       	ldi	r24, 0x01	; 1
 970:	08 c0       	rjmp	.+16     	; 0x982 <__stack+0x123>
 972:	81 e0       	ldi	r24, 0x01	; 1
 974:	06 c0       	rjmp	.+12     	; 0x982 <__stack+0x123>
 976:	fc 01       	movw	r30, r24
 978:	d0 8e       	std	Z+24, r13	; 0x18
 97a:	c7 8a       	std	Z+23, r12	; 0x17
 97c:	c6 01       	movw	r24, r12
 97e:	35 cf       	rjmp	.-406    	; 0x7ea <xTaskGenericCreate+0x58>
 980:	8f ef       	ldi	r24, 0xFF	; 255
 982:	df 91       	pop	r29
 984:	cf 91       	pop	r28
 986:	1f 91       	pop	r17
 988:	0f 91       	pop	r16
 98a:	ff 90       	pop	r15
 98c:	ef 90       	pop	r14
 98e:	df 90       	pop	r13
 990:	cf 90       	pop	r12
 992:	bf 90       	pop	r11
 994:	af 90       	pop	r10
 996:	9f 90       	pop	r9
 998:	8f 90       	pop	r8
 99a:	7f 90       	pop	r7
 99c:	6f 90       	pop	r6
 99e:	5f 90       	pop	r5
 9a0:	4f 90       	pop	r4
 9a2:	08 95       	ret

000009a4 <vTaskDelete>:
 9a4:	ef 92       	push	r14
 9a6:	ff 92       	push	r15
 9a8:	0f 93       	push	r16
 9aa:	1f 93       	push	r17
 9ac:	cf 93       	push	r28
 9ae:	df 93       	push	r29
 9b0:	ec 01       	movw	r28, r24
 9b2:	0f b6       	in	r0, 0x3f	; 63
 9b4:	f8 94       	cli
 9b6:	0f 92       	push	r0
 9b8:	80 91 d5 06 	lds	r24, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 9bc:	90 91 d6 06 	lds	r25, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 9c0:	8c 17       	cp	r24, r28
 9c2:	9d 07       	cpc	r25, r29
 9c4:	11 f0       	breq	.+4      	; 0x9ca <vTaskDelete+0x26>
 9c6:	20 97       	sbiw	r28, 0x00	; 0
 9c8:	39 f4       	brne	.+14     	; 0x9d8 <vTaskDelete+0x34>
 9ca:	c0 91 d5 06 	lds	r28, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 9ce:	d0 91 d6 06 	lds	r29, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 9d2:	e1 2c       	mov	r14, r1
 9d4:	f1 2c       	mov	r15, r1
 9d6:	01 c0       	rjmp	.+2      	; 0x9da <vTaskDelete+0x36>
 9d8:	7e 01       	movw	r14, r28
 9da:	8e 01       	movw	r16, r28
 9dc:	0e 5f       	subi	r16, 0xFE	; 254
 9de:	1f 4f       	sbci	r17, 0xFF	; 255
 9e0:	c8 01       	movw	r24, r16
 9e2:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
 9e6:	8c 89       	ldd	r24, Y+20	; 0x14
 9e8:	9d 89       	ldd	r25, Y+21	; 0x15
 9ea:	89 2b       	or	r24, r25
 9ec:	21 f0       	breq	.+8      	; 0x9f6 <vTaskDelete+0x52>
 9ee:	ce 01       	movw	r24, r28
 9f0:	0c 96       	adiw	r24, 0x0c	; 12
 9f2:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
 9f6:	b8 01       	movw	r22, r16
 9f8:	80 e8       	ldi	r24, 0x80	; 128
 9fa:	96 e0       	ldi	r25, 0x06	; 6
 9fc:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>
 a00:	80 91 7f 06 	lds	r24, 0x067F	; 0x80067f <uxTasksDeleted>
 a04:	8f 5f       	subi	r24, 0xFF	; 255
 a06:	80 93 7f 06 	sts	0x067F, r24	; 0x80067f <uxTasksDeleted>
 a0a:	80 91 74 06 	lds	r24, 0x0674	; 0x800674 <uxTaskNumber>
 a0e:	8f 5f       	subi	r24, 0xFF	; 255
 a10:	80 93 74 06 	sts	0x0674, r24	; 0x800674 <uxTaskNumber>
 a14:	0f 90       	pop	r0
 a16:	0f be       	out	0x3f, r0	; 63
 a18:	80 91 79 06 	lds	r24, 0x0679	; 0x800679 <xSchedulerRunning>
 a1c:	88 23       	and	r24, r24
 a1e:	21 f0       	breq	.+8      	; 0xa28 <vTaskDelete+0x84>
 a20:	ef 28       	or	r14, r15
 a22:	11 f4       	brne	.+4      	; 0xa28 <vTaskDelete+0x84>
 a24:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
 a28:	df 91       	pop	r29
 a2a:	cf 91       	pop	r28
 a2c:	1f 91       	pop	r17
 a2e:	0f 91       	pop	r16
 a30:	ff 90       	pop	r15
 a32:	ef 90       	pop	r14
 a34:	08 95       	ret

00000a36 <vTaskStartScheduler>:
 a36:	af 92       	push	r10
 a38:	bf 92       	push	r11
 a3a:	cf 92       	push	r12
 a3c:	df 92       	push	r13
 a3e:	ef 92       	push	r14
 a40:	ff 92       	push	r15
 a42:	0f 93       	push	r16
 a44:	a1 2c       	mov	r10, r1
 a46:	b1 2c       	mov	r11, r1
 a48:	c1 2c       	mov	r12, r1
 a4a:	d1 2c       	mov	r13, r1
 a4c:	e1 2c       	mov	r14, r1
 a4e:	f1 2c       	mov	r15, r1
 a50:	00 e0       	ldi	r16, 0x00	; 0
 a52:	20 e0       	ldi	r18, 0x00	; 0
 a54:	30 e0       	ldi	r19, 0x00	; 0
 a56:	45 e5       	ldi	r20, 0x55	; 85
 a58:	50 e0       	ldi	r21, 0x00	; 0
 a5a:	6f e8       	ldi	r22, 0x8F	; 143
 a5c:	70 e0       	ldi	r23, 0x00	; 0
 a5e:	89 e0       	ldi	r24, 0x09	; 9
 a60:	97 e0       	ldi	r25, 0x07	; 7
 a62:	0e 94 c9 03 	call	0x792	; 0x792 <xTaskGenericCreate>
 a66:	81 30       	cpi	r24, 0x01	; 1
 a68:	49 f4       	brne	.+18     	; 0xa7c <vTaskStartScheduler+0x46>
 a6a:	f8 94       	cli
 a6c:	80 93 79 06 	sts	0x0679, r24	; 0x800679 <xSchedulerRunning>
 a70:	10 92 7d 06 	sts	0x067D, r1	; 0x80067d <xTickCount+0x1>
 a74:	10 92 7c 06 	sts	0x067C, r1	; 0x80067c <xTickCount>
 a78:	0e 94 02 02 	call	0x404	; 0x404 <xPortStartScheduler>
 a7c:	0f 91       	pop	r16
 a7e:	ff 90       	pop	r15
 a80:	ef 90       	pop	r14
 a82:	df 90       	pop	r13
 a84:	cf 90       	pop	r12
 a86:	bf 90       	pop	r11
 a88:	af 90       	pop	r10
 a8a:	08 95       	ret

00000a8c <vTaskSuspendAll>:
 a8c:	80 91 78 06 	lds	r24, 0x0678	; 0x800678 <uxSchedulerSuspended>
 a90:	8f 5f       	subi	r24, 0xFF	; 255
 a92:	80 93 78 06 	sts	0x0678, r24	; 0x800678 <uxSchedulerSuspended>
 a96:	08 95       	ret

00000a98 <xTaskGetTickCount>:
 a98:	0f b6       	in	r0, 0x3f	; 63
 a9a:	f8 94       	cli
 a9c:	0f 92       	push	r0
 a9e:	80 91 7c 06 	lds	r24, 0x067C	; 0x80067c <xTickCount>
 aa2:	90 91 7d 06 	lds	r25, 0x067D	; 0x80067d <xTickCount+0x1>
 aa6:	0f 90       	pop	r0
 aa8:	0f be       	out	0x3f, r0	; 63
 aaa:	08 95       	ret

00000aac <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
 aac:	0f 93       	push	r16
 aae:	1f 93       	push	r17
 ab0:	cf 93       	push	r28
 ab2:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 ab4:	80 91 78 06 	lds	r24, 0x0678	; 0x800678 <uxSchedulerSuspended>
 ab8:	81 11       	cpse	r24, r1
 aba:	b2 c0       	rjmp	.+356    	; 0xc20 <vTaskIncrementTick+0x174>
	{
		++xTickCount;
 abc:	80 91 7c 06 	lds	r24, 0x067C	; 0x80067c <xTickCount>
 ac0:	90 91 7d 06 	lds	r25, 0x067D	; 0x80067d <xTickCount+0x1>
 ac4:	01 96       	adiw	r24, 0x01	; 1
 ac6:	90 93 7d 06 	sts	0x067D, r25	; 0x80067d <xTickCount+0x1>
 aca:	80 93 7c 06 	sts	0x067C, r24	; 0x80067c <xTickCount>
		if( xTickCount == ( portTickType ) 0U )
 ace:	80 91 7c 06 	lds	r24, 0x067C	; 0x80067c <xTickCount>
 ad2:	90 91 7d 06 	lds	r25, 0x067D	; 0x80067d <xTickCount+0x1>
 ad6:	89 2b       	or	r24, r25
 ad8:	99 f5       	brne	.+102    	; 0xb40 <vTaskIncrementTick+0x94>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
 ada:	80 91 94 06 	lds	r24, 0x0694	; 0x800694 <pxDelayedTaskList>
 ade:	90 91 95 06 	lds	r25, 0x0695	; 0x800695 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 ae2:	20 91 92 06 	lds	r18, 0x0692	; 0x800692 <pxOverflowDelayedTaskList>
 ae6:	30 91 93 06 	lds	r19, 0x0693	; 0x800693 <pxOverflowDelayedTaskList+0x1>
 aea:	30 93 95 06 	sts	0x0695, r19	; 0x800695 <pxDelayedTaskList+0x1>
 aee:	20 93 94 06 	sts	0x0694, r18	; 0x800694 <pxDelayedTaskList>
			pxOverflowDelayedTaskList = pxTemp;
 af2:	90 93 93 06 	sts	0x0693, r25	; 0x800693 <pxOverflowDelayedTaskList+0x1>
 af6:	80 93 92 06 	sts	0x0692, r24	; 0x800692 <pxOverflowDelayedTaskList>
			xNumOfOverflows++;
 afa:	80 91 75 06 	lds	r24, 0x0675	; 0x800675 <xNumOfOverflows>
 afe:	8f 5f       	subi	r24, 0xFF	; 255
 b00:	80 93 75 06 	sts	0x0675, r24	; 0x800675 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 b04:	e0 91 94 06 	lds	r30, 0x0694	; 0x800694 <pxDelayedTaskList>
 b08:	f0 91 95 06 	lds	r31, 0x0695	; 0x800695 <pxDelayedTaskList+0x1>
 b0c:	80 81       	ld	r24, Z
 b0e:	81 11       	cpse	r24, r1
 b10:	07 c0       	rjmp	.+14     	; 0xb20 <vTaskIncrementTick+0x74>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
 b12:	8f ef       	ldi	r24, 0xFF	; 255
 b14:	9f ef       	ldi	r25, 0xFF	; 255
 b16:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 b1a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 b1e:	10 c0       	rjmp	.+32     	; 0xb40 <vTaskIncrementTick+0x94>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 b20:	e0 91 94 06 	lds	r30, 0x0694	; 0x800694 <pxDelayedTaskList>
 b24:	f0 91 95 06 	lds	r31, 0x0695	; 0x800695 <pxDelayedTaskList+0x1>
 b28:	05 80       	ldd	r0, Z+5	; 0x05
 b2a:	f6 81       	ldd	r31, Z+6	; 0x06
 b2c:	e0 2d       	mov	r30, r0
 b2e:	06 80       	ldd	r0, Z+6	; 0x06
 b30:	f7 81       	ldd	r31, Z+7	; 0x07
 b32:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 b34:	82 81       	ldd	r24, Z+2	; 0x02
 b36:	93 81       	ldd	r25, Z+3	; 0x03
 b38:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 b3c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 b40:	20 91 7c 06 	lds	r18, 0x067C	; 0x80067c <xTickCount>
 b44:	30 91 7d 06 	lds	r19, 0x067D	; 0x80067d <xTickCount+0x1>
 b48:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 b4c:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 b50:	28 17       	cp	r18, r24
 b52:	39 07       	cpc	r19, r25
 b54:	08 f4       	brcc	.+2      	; 0xb58 <vTaskIncrementTick+0xac>
 b56:	69 c0       	rjmp	.+210    	; 0xc2a <vTaskIncrementTick+0x17e>
 b58:	e0 91 94 06 	lds	r30, 0x0694	; 0x800694 <pxDelayedTaskList>
 b5c:	f0 91 95 06 	lds	r31, 0x0695	; 0x800695 <pxDelayedTaskList+0x1>
 b60:	80 81       	ld	r24, Z
 b62:	88 23       	and	r24, r24
 b64:	99 f0       	breq	.+38     	; 0xb8c <vTaskIncrementTick+0xe0>
 b66:	e0 91 94 06 	lds	r30, 0x0694	; 0x800694 <pxDelayedTaskList>
 b6a:	f0 91 95 06 	lds	r31, 0x0695	; 0x800695 <pxDelayedTaskList+0x1>
 b6e:	05 80       	ldd	r0, Z+5	; 0x05
 b70:	f6 81       	ldd	r31, Z+6	; 0x06
 b72:	e0 2d       	mov	r30, r0
 b74:	c6 81       	ldd	r28, Z+6	; 0x06
 b76:	d7 81       	ldd	r29, Z+7	; 0x07
 b78:	8a 81       	ldd	r24, Y+2	; 0x02
 b7a:	9b 81       	ldd	r25, Y+3	; 0x03
 b7c:	20 91 7c 06 	lds	r18, 0x067C	; 0x80067c <xTickCount>
 b80:	30 91 7d 06 	lds	r19, 0x067D	; 0x80067d <xTickCount+0x1>
 b84:	28 17       	cp	r18, r24
 b86:	39 07       	cpc	r19, r25
 b88:	f8 f4       	brcc	.+62     	; 0xbc8 <vTaskIncrementTick+0x11c>
 b8a:	19 c0       	rjmp	.+50     	; 0xbbe <vTaskIncrementTick+0x112>
 b8c:	8f ef       	ldi	r24, 0xFF	; 255
 b8e:	9f ef       	ldi	r25, 0xFF	; 255
 b90:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 b94:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 b98:	48 c0       	rjmp	.+144    	; 0xc2a <vTaskIncrementTick+0x17e>
 b9a:	e0 91 94 06 	lds	r30, 0x0694	; 0x800694 <pxDelayedTaskList>
 b9e:	f0 91 95 06 	lds	r31, 0x0695	; 0x800695 <pxDelayedTaskList+0x1>
 ba2:	05 80       	ldd	r0, Z+5	; 0x05
 ba4:	f6 81       	ldd	r31, Z+6	; 0x06
 ba6:	e0 2d       	mov	r30, r0
 ba8:	c6 81       	ldd	r28, Z+6	; 0x06
 baa:	d7 81       	ldd	r29, Z+7	; 0x07
 bac:	8a 81       	ldd	r24, Y+2	; 0x02
 bae:	9b 81       	ldd	r25, Y+3	; 0x03
 bb0:	20 91 7c 06 	lds	r18, 0x067C	; 0x80067c <xTickCount>
 bb4:	30 91 7d 06 	lds	r19, 0x067D	; 0x80067d <xTickCount+0x1>
 bb8:	28 17       	cp	r18, r24
 bba:	39 07       	cpc	r19, r25
 bbc:	28 f4       	brcc	.+10     	; 0xbc8 <vTaskIncrementTick+0x11c>
 bbe:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 bc2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 bc6:	31 c0       	rjmp	.+98     	; 0xc2a <vTaskIncrementTick+0x17e>
 bc8:	8e 01       	movw	r16, r28
 bca:	0e 5f       	subi	r16, 0xFE	; 254
 bcc:	1f 4f       	sbci	r17, 0xFF	; 255
 bce:	c8 01       	movw	r24, r16
 bd0:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
 bd4:	8c 89       	ldd	r24, Y+20	; 0x14
 bd6:	9d 89       	ldd	r25, Y+21	; 0x15
 bd8:	89 2b       	or	r24, r25
 bda:	21 f0       	breq	.+8      	; 0xbe4 <vTaskIncrementTick+0x138>
 bdc:	ce 01       	movw	r24, r28
 bde:	0c 96       	adiw	r24, 0x0c	; 12
 be0:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
 be4:	8e 89       	ldd	r24, Y+22	; 0x16
 be6:	90 91 7a 06 	lds	r25, 0x067A	; 0x80067a <uxTopReadyPriority>
 bea:	98 17       	cp	r25, r24
 bec:	10 f4       	brcc	.+4      	; 0xbf2 <vTaskIncrementTick+0x146>
 bee:	80 93 7a 06 	sts	0x067A, r24	; 0x80067a <uxTopReadyPriority>
 bf2:	90 e0       	ldi	r25, 0x00	; 0
 bf4:	9c 01       	movw	r18, r24
 bf6:	22 0f       	add	r18, r18
 bf8:	33 1f       	adc	r19, r19
 bfa:	22 0f       	add	r18, r18
 bfc:	33 1f       	adc	r19, r19
 bfe:	22 0f       	add	r18, r18
 c00:	33 1f       	adc	r19, r19
 c02:	82 0f       	add	r24, r18
 c04:	93 1f       	adc	r25, r19
 c06:	b8 01       	movw	r22, r16
 c08:	88 55       	subi	r24, 0x58	; 88
 c0a:	99 4f       	sbci	r25, 0xF9	; 249
 c0c:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>
 c10:	e0 91 94 06 	lds	r30, 0x0694	; 0x800694 <pxDelayedTaskList>
 c14:	f0 91 95 06 	lds	r31, 0x0695	; 0x800695 <pxDelayedTaskList+0x1>
 c18:	80 81       	ld	r24, Z
 c1a:	81 11       	cpse	r24, r1
 c1c:	be cf       	rjmp	.-132    	; 0xb9a <vTaskIncrementTick+0xee>
 c1e:	b6 cf       	rjmp	.-148    	; 0xb8c <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
 c20:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <uxMissedTicks>
 c24:	8f 5f       	subi	r24, 0xFF	; 255
 c26:	80 93 77 06 	sts	0x0677, r24	; 0x800677 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 c2a:	df 91       	pop	r29
 c2c:	cf 91       	pop	r28
 c2e:	1f 91       	pop	r17
 c30:	0f 91       	pop	r16
 c32:	08 95       	ret

00000c34 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 c34:	cf 92       	push	r12
 c36:	df 92       	push	r13
 c38:	ef 92       	push	r14
 c3a:	ff 92       	push	r15
 c3c:	0f 93       	push	r16
 c3e:	1f 93       	push	r17
 c40:	cf 93       	push	r28
 c42:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 c44:	0f b6       	in	r0, 0x3f	; 63
 c46:	f8 94       	cli
 c48:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 c4a:	80 91 78 06 	lds	r24, 0x0678	; 0x800678 <uxSchedulerSuspended>
 c4e:	81 50       	subi	r24, 0x01	; 1
 c50:	80 93 78 06 	sts	0x0678, r24	; 0x800678 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 c54:	80 91 78 06 	lds	r24, 0x0678	; 0x800678 <uxSchedulerSuspended>
 c58:	81 11       	cpse	r24, r1
 c5a:	63 c0       	rjmp	.+198    	; 0xd22 <xTaskResumeAll+0xee>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 c5c:	80 91 7e 06 	lds	r24, 0x067E	; 0x80067e <uxCurrentNumberOfTasks>
 c60:	81 11       	cpse	r24, r1
 c62:	32 c0       	rjmp	.+100    	; 0xcc8 <xTaskResumeAll+0x94>
 c64:	61 c0       	rjmp	.+194    	; 0xd28 <xTaskResumeAll+0xf4>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 c66:	d7 01       	movw	r26, r14
 c68:	15 96       	adiw	r26, 0x05	; 5
 c6a:	ed 91       	ld	r30, X+
 c6c:	fc 91       	ld	r31, X
 c6e:	16 97       	sbiw	r26, 0x06	; 6
 c70:	c6 81       	ldd	r28, Z+6	; 0x06
 c72:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
 c74:	ce 01       	movw	r24, r28
 c76:	0c 96       	adiw	r24, 0x0c	; 12
 c78:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 c7c:	8e 01       	movw	r16, r28
 c7e:	0e 5f       	subi	r16, 0xFE	; 254
 c80:	1f 4f       	sbci	r17, 0xFF	; 255
 c82:	c8 01       	movw	r24, r16
 c84:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 c88:	8e 89       	ldd	r24, Y+22	; 0x16
 c8a:	90 91 7a 06 	lds	r25, 0x067A	; 0x80067a <uxTopReadyPriority>
 c8e:	98 17       	cp	r25, r24
 c90:	10 f4       	brcc	.+4      	; 0xc96 <xTaskResumeAll+0x62>
 c92:	80 93 7a 06 	sts	0x067A, r24	; 0x80067a <uxTopReadyPriority>
 c96:	90 e0       	ldi	r25, 0x00	; 0
 c98:	9c 01       	movw	r18, r24
 c9a:	22 0f       	add	r18, r18
 c9c:	33 1f       	adc	r19, r19
 c9e:	22 0f       	add	r18, r18
 ca0:	33 1f       	adc	r19, r19
 ca2:	22 0f       	add	r18, r18
 ca4:	33 1f       	adc	r19, r19
 ca6:	82 0f       	add	r24, r18
 ca8:	93 1f       	adc	r25, r19
 caa:	b8 01       	movw	r22, r16
 cac:	88 55       	subi	r24, 0x58	; 88
 cae:	99 4f       	sbci	r25, 0xF9	; 249
 cb0:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 cb4:	e0 91 d5 06 	lds	r30, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 cb8:	f0 91 d6 06 	lds	r31, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 cbc:	9e 89       	ldd	r25, Y+22	; 0x16
 cbe:	86 89       	ldd	r24, Z+22	; 0x16
 cc0:	98 17       	cp	r25, r24
 cc2:	58 f0       	brcs	.+22     	; 0xcda <xTaskResumeAll+0xa6>
					{
						xYieldRequired = pdTRUE;
 cc4:	dc 2c       	mov	r13, r12
 cc6:	09 c0       	rjmp	.+18     	; 0xcda <xTaskResumeAll+0xa6>
 cc8:	d1 2c       	mov	r13, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 cca:	0f 2e       	mov	r0, r31
 ccc:	f9 e8       	ldi	r31, 0x89	; 137
 cce:	ef 2e       	mov	r14, r31
 cd0:	f6 e0       	ldi	r31, 0x06	; 6
 cd2:	ff 2e       	mov	r15, r31
 cd4:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
 cd6:	cc 24       	eor	r12, r12
 cd8:	c3 94       	inc	r12
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 cda:	f7 01       	movw	r30, r14
 cdc:	80 81       	ld	r24, Z
 cde:	81 11       	cpse	r24, r1
 ce0:	c2 cf       	rjmp	.-124    	; 0xc66 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 ce2:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <uxMissedTicks>
 ce6:	88 23       	and	r24, r24
 ce8:	79 f0       	breq	.+30     	; 0xd08 <xTaskResumeAll+0xd4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 cea:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <uxMissedTicks>
 cee:	88 23       	and	r24, r24
 cf0:	59 f0       	breq	.+22     	; 0xd08 <xTaskResumeAll+0xd4>
					{
						vTaskIncrementTick();
 cf2:	0e 94 56 05 	call	0xaac	; 0xaac <vTaskIncrementTick>
						--uxMissedTicks;
 cf6:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <uxMissedTicks>
 cfa:	81 50       	subi	r24, 0x01	; 1
 cfc:	80 93 77 06 	sts	0x0677, r24	; 0x800677 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 d00:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <uxMissedTicks>
 d04:	81 11       	cpse	r24, r1
 d06:	f5 cf       	rjmp	.-22     	; 0xcf2 <xTaskResumeAll+0xbe>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 d08:	f1 e0       	ldi	r31, 0x01	; 1
 d0a:	df 16       	cp	r13, r31
 d0c:	21 f0       	breq	.+8      	; 0xd16 <xTaskResumeAll+0xe2>
 d0e:	80 91 76 06 	lds	r24, 0x0676	; 0x800676 <xMissedYield>
 d12:	81 30       	cpi	r24, 0x01	; 1
 d14:	41 f4       	brne	.+16     	; 0xd26 <xTaskResumeAll+0xf2>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
 d16:	10 92 76 06 	sts	0x0676, r1	; 0x800676 <xMissedYield>
					portYIELD_WITHIN_API();
 d1a:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
 d1e:	81 e0       	ldi	r24, 0x01	; 1
 d20:	03 c0       	rjmp	.+6      	; 0xd28 <xTaskResumeAll+0xf4>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 d22:	80 e0       	ldi	r24, 0x00	; 0
 d24:	01 c0       	rjmp	.+2      	; 0xd28 <xTaskResumeAll+0xf4>
 d26:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 d28:	0f 90       	pop	r0
 d2a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 d2c:	df 91       	pop	r29
 d2e:	cf 91       	pop	r28
 d30:	1f 91       	pop	r17
 d32:	0f 91       	pop	r16
 d34:	ff 90       	pop	r15
 d36:	ef 90       	pop	r14
 d38:	df 90       	pop	r13
 d3a:	cf 90       	pop	r12
 d3c:	08 95       	ret

00000d3e <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
 d3e:	0f 93       	push	r16
 d40:	1f 93       	push	r17
 d42:	cf 93       	push	r28
 d44:	df 93       	push	r29
 d46:	8c 01       	movw	r16, r24
 d48:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
 d4a:	0e 94 46 05 	call	0xa8c	; 0xa8c <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 d4e:	f8 01       	movw	r30, r16
 d50:	80 81       	ld	r24, Z
 d52:	91 81       	ldd	r25, Z+1	; 0x01
 d54:	c8 0f       	add	r28, r24
 d56:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
 d58:	20 91 7c 06 	lds	r18, 0x067C	; 0x80067c <xTickCount>
 d5c:	30 91 7d 06 	lds	r19, 0x067D	; 0x80067d <xTickCount+0x1>
 d60:	28 17       	cp	r18, r24
 d62:	39 07       	cpc	r19, r25
 d64:	68 f4       	brcc	.+26     	; 0xd80 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 d66:	c8 17       	cp	r28, r24
 d68:	d9 07       	cpc	r29, r25
 d6a:	50 f5       	brcc	.+84     	; 0xdc0 <vTaskDelayUntil+0x82>
 d6c:	80 91 7c 06 	lds	r24, 0x067C	; 0x80067c <xTickCount>
 d70:	90 91 7d 06 	lds	r25, 0x067D	; 0x80067d <xTickCount+0x1>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 d74:	d1 83       	std	Z+1, r29	; 0x01
 d76:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
 d78:	8c 17       	cp	r24, r28
 d7a:	9d 07       	cpc	r25, r29
 d7c:	b0 f4       	brcc	.+44     	; 0xdaa <vTaskDelayUntil+0x6c>
 d7e:	0b c0       	rjmp	.+22     	; 0xd96 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 d80:	c8 17       	cp	r28, r24
 d82:	d9 07       	cpc	r29, r25
 d84:	c8 f0       	brcs	.+50     	; 0xdb8 <vTaskDelayUntil+0x7a>
 d86:	80 91 7c 06 	lds	r24, 0x067C	; 0x80067c <xTickCount>
 d8a:	90 91 7d 06 	lds	r25, 0x067D	; 0x80067d <xTickCount+0x1>
 d8e:	8c 17       	cp	r24, r28
 d90:	9d 07       	cpc	r25, r29
 d92:	90 f0       	brcs	.+36     	; 0xdb8 <vTaskDelayUntil+0x7a>
 d94:	15 c0       	rjmp	.+42     	; 0xdc0 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 d96:	80 91 d5 06 	lds	r24, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 d9a:	90 91 d6 06 	lds	r25, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 d9e:	02 96       	adiw	r24, 0x02	; 2
 da0:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 da4:	ce 01       	movw	r24, r28
 da6:	0e 94 92 03 	call	0x724	; 0x724 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 daa:	0e 94 1a 06 	call	0xc34	; 0xc34 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 dae:	81 11       	cpse	r24, r1
 db0:	0b c0       	rjmp	.+22     	; 0xdc8 <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
 db2:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
		}
	}
 db6:	08 c0       	rjmp	.+16     	; 0xdc8 <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 db8:	f8 01       	movw	r30, r16
 dba:	d1 83       	std	Z+1, r29	; 0x01
 dbc:	c0 83       	st	Z, r28
 dbe:	eb cf       	rjmp	.-42     	; 0xd96 <vTaskDelayUntil+0x58>
 dc0:	f8 01       	movw	r30, r16
 dc2:	d1 83       	std	Z+1, r29	; 0x01
 dc4:	c0 83       	st	Z, r28
 dc6:	f1 cf       	rjmp	.-30     	; 0xdaa <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 dc8:	df 91       	pop	r29
 dca:	cf 91       	pop	r28
 dcc:	1f 91       	pop	r17
 dce:	0f 91       	pop	r16
 dd0:	08 95       	ret

00000dd2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 dd2:	cf 93       	push	r28
 dd4:	df 93       	push	r29
 dd6:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 dd8:	89 2b       	or	r24, r25
 dda:	b1 f0       	breq	.+44     	; 0xe08 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
 ddc:	0e 94 46 05 	call	0xa8c	; 0xa8c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 de0:	80 91 7c 06 	lds	r24, 0x067C	; 0x80067c <xTickCount>
 de4:	90 91 7d 06 	lds	r25, 0x067D	; 0x80067d <xTickCount+0x1>
 de8:	c8 0f       	add	r28, r24
 dea:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 dec:	80 91 d5 06 	lds	r24, 0x06D5	; 0x8006d5 <pxCurrentTCB>
 df0:	90 91 d6 06 	lds	r25, 0x06D6	; 0x8006d6 <pxCurrentTCB+0x1>
 df4:	02 96       	adiw	r24, 0x02	; 2
 df6:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 dfa:	ce 01       	movw	r24, r28
 dfc:	0e 94 92 03 	call	0x724	; 0x724 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 e00:	0e 94 1a 06 	call	0xc34	; 0xc34 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 e04:	81 11       	cpse	r24, r1
 e06:	02 c0       	rjmp	.+4      	; 0xe0c <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
 e08:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
		}
	}
 e0c:	df 91       	pop	r29
 e0e:	cf 91       	pop	r28
 e10:	08 95       	ret

00000e12 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 e12:	00 e8       	ldi	r16, 0x80	; 128
 e14:	16 e0       	ldi	r17, 0x06	; 6
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 e16:	80 91 7f 06 	lds	r24, 0x067F	; 0x80067f <uxTasksDeleted>
 e1a:	88 23       	and	r24, r24
 e1c:	49 f1       	breq	.+82     	; 0xe70 <prvIdleTask+0x5e>
		{
			vTaskSuspendAll();
 e1e:	0e 94 46 05 	call	0xa8c	; 0xa8c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 e22:	d8 01       	movw	r26, r16
 e24:	cc 91       	ld	r28, X
			xTaskResumeAll();
 e26:	0e 94 1a 06 	call	0xc34	; 0xc34 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 e2a:	cc 23       	and	r28, r28
 e2c:	09 f1       	breq	.+66     	; 0xe70 <prvIdleTask+0x5e>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 e2e:	0f b6       	in	r0, 0x3f	; 63
 e30:	f8 94       	cli
 e32:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 e34:	d8 01       	movw	r26, r16
 e36:	15 96       	adiw	r26, 0x05	; 5
 e38:	ed 91       	ld	r30, X+
 e3a:	fc 91       	ld	r31, X
 e3c:	16 97       	sbiw	r26, 0x06	; 6
 e3e:	c6 81       	ldd	r28, Z+6	; 0x06
 e40:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
 e42:	ce 01       	movw	r24, r28
 e44:	02 96       	adiw	r24, 0x02	; 2
 e46:	0e 94 70 01 	call	0x2e0	; 0x2e0 <vListRemove>
					--uxCurrentNumberOfTasks;
 e4a:	80 91 7e 06 	lds	r24, 0x067E	; 0x80067e <uxCurrentNumberOfTasks>
 e4e:	81 50       	subi	r24, 0x01	; 1
 e50:	80 93 7e 06 	sts	0x067E, r24	; 0x80067e <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
 e54:	80 91 7f 06 	lds	r24, 0x067F	; 0x80067f <uxTasksDeleted>
 e58:	81 50       	subi	r24, 0x01	; 1
 e5a:	80 93 7f 06 	sts	0x067F, r24	; 0x80067f <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
 e5e:	0f 90       	pop	r0
 e60:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 e62:	8f 89       	ldd	r24, Y+23	; 0x17
 e64:	98 8d       	ldd	r25, Y+24	; 0x18
 e66:	0e 94 6f 00 	call	0xde	; 0xde <vPortFree>
		vPortFree( pxTCB );
 e6a:	ce 01       	movw	r24, r28
 e6c:	0e 94 6f 00 	call	0xde	; 0xde <vPortFree>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
 e70:	0e 94 37 02 	call	0x46e	; 0x46e <vPortYield>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 e74:	d0 cf       	rjmp	.-96     	; 0xe16 <prvIdleTask+0x4>

00000e76 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 e76:	80 91 78 06 	lds	r24, 0x0678	; 0x800678 <uxSchedulerSuspended>
 e7a:	81 11       	cpse	r24, r1
 e7c:	13 c0       	rjmp	.+38     	; 0xea4 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 e7e:	80 91 7a 06 	lds	r24, 0x067A	; 0x80067a <uxTopReadyPriority>
 e82:	90 e0       	ldi	r25, 0x00	; 0
 e84:	fc 01       	movw	r30, r24
 e86:	ee 0f       	add	r30, r30
 e88:	ff 1f       	adc	r31, r31
 e8a:	ee 0f       	add	r30, r30
 e8c:	ff 1f       	adc	r31, r31
 e8e:	ee 0f       	add	r30, r30
 e90:	ff 1f       	adc	r31, r31
 e92:	8e 0f       	add	r24, r30
 e94:	9f 1f       	adc	r25, r31
 e96:	fc 01       	movw	r30, r24
 e98:	e8 55       	subi	r30, 0x58	; 88
 e9a:	f9 4f       	sbci	r31, 0xF9	; 249
 e9c:	80 81       	ld	r24, Z
 e9e:	88 23       	and	r24, r24
 ea0:	29 f0       	breq	.+10     	; 0xeac <vTaskSwitchContext+0x36>
 ea2:	1b c0       	rjmp	.+54     	; 0xeda <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 ea4:	81 e0       	ldi	r24, 0x01	; 1
 ea6:	80 93 76 06 	sts	0x0676, r24	; 0x800676 <xMissedYield>
 eaa:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 eac:	80 91 7a 06 	lds	r24, 0x067A	; 0x80067a <uxTopReadyPriority>
 eb0:	81 50       	subi	r24, 0x01	; 1
 eb2:	80 93 7a 06 	sts	0x067A, r24	; 0x80067a <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 eb6:	80 91 7a 06 	lds	r24, 0x067A	; 0x80067a <uxTopReadyPriority>
 eba:	90 e0       	ldi	r25, 0x00	; 0
 ebc:	fc 01       	movw	r30, r24
 ebe:	ee 0f       	add	r30, r30
 ec0:	ff 1f       	adc	r31, r31
 ec2:	ee 0f       	add	r30, r30
 ec4:	ff 1f       	adc	r31, r31
 ec6:	ee 0f       	add	r30, r30
 ec8:	ff 1f       	adc	r31, r31
 eca:	8e 0f       	add	r24, r30
 ecc:	9f 1f       	adc	r25, r31
 ece:	fc 01       	movw	r30, r24
 ed0:	e8 55       	subi	r30, 0x58	; 88
 ed2:	f9 4f       	sbci	r31, 0xF9	; 249
 ed4:	80 81       	ld	r24, Z
 ed6:	88 23       	and	r24, r24
 ed8:	49 f3       	breq	.-46     	; 0xeac <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 eda:	80 91 7a 06 	lds	r24, 0x067A	; 0x80067a <uxTopReadyPriority>
 ede:	90 e0       	ldi	r25, 0x00	; 0
 ee0:	9c 01       	movw	r18, r24
 ee2:	22 0f       	add	r18, r18
 ee4:	33 1f       	adc	r19, r19
 ee6:	22 0f       	add	r18, r18
 ee8:	33 1f       	adc	r19, r19
 eea:	22 0f       	add	r18, r18
 eec:	33 1f       	adc	r19, r19
 eee:	28 0f       	add	r18, r24
 ef0:	39 1f       	adc	r19, r25
 ef2:	d9 01       	movw	r26, r18
 ef4:	a8 55       	subi	r26, 0x58	; 88
 ef6:	b9 4f       	sbci	r27, 0xF9	; 249
 ef8:	11 96       	adiw	r26, 0x01	; 1
 efa:	ed 91       	ld	r30, X+
 efc:	fc 91       	ld	r31, X
 efe:	12 97       	sbiw	r26, 0x02	; 2
 f00:	02 80       	ldd	r0, Z+2	; 0x02
 f02:	f3 81       	ldd	r31, Z+3	; 0x03
 f04:	e0 2d       	mov	r30, r0
 f06:	12 96       	adiw	r26, 0x02	; 2
 f08:	fc 93       	st	X, r31
 f0a:	ee 93       	st	-X, r30
 f0c:	11 97       	sbiw	r26, 0x01	; 1
 f0e:	25 55       	subi	r18, 0x55	; 85
 f10:	39 4f       	sbci	r19, 0xF9	; 249
 f12:	e2 17       	cp	r30, r18
 f14:	f3 07       	cpc	r31, r19
 f16:	29 f4       	brne	.+10     	; 0xf22 <vTaskSwitchContext+0xac>
 f18:	22 81       	ldd	r18, Z+2	; 0x02
 f1a:	33 81       	ldd	r19, Z+3	; 0x03
 f1c:	fd 01       	movw	r30, r26
 f1e:	32 83       	std	Z+2, r19	; 0x02
 f20:	21 83       	std	Z+1, r18	; 0x01
 f22:	fc 01       	movw	r30, r24
 f24:	ee 0f       	add	r30, r30
 f26:	ff 1f       	adc	r31, r31
 f28:	ee 0f       	add	r30, r30
 f2a:	ff 1f       	adc	r31, r31
 f2c:	ee 0f       	add	r30, r30
 f2e:	ff 1f       	adc	r31, r31
 f30:	8e 0f       	add	r24, r30
 f32:	9f 1f       	adc	r25, r31
 f34:	fc 01       	movw	r30, r24
 f36:	e8 55       	subi	r30, 0x58	; 88
 f38:	f9 4f       	sbci	r31, 0xF9	; 249
 f3a:	01 80       	ldd	r0, Z+1	; 0x01
 f3c:	f2 81       	ldd	r31, Z+2	; 0x02
 f3e:	e0 2d       	mov	r30, r0
 f40:	86 81       	ldd	r24, Z+6	; 0x06
 f42:	97 81       	ldd	r25, Z+7	; 0x07
 f44:	90 93 d6 06 	sts	0x06D6, r25	; 0x8006d6 <pxCurrentTCB+0x1>
 f48:	80 93 d5 06 	sts	0x06D5, r24	; 0x8006d5 <pxCurrentTCB>
 f4c:	08 95       	ret

00000f4e <memset>:
 f4e:	dc 01       	movw	r26, r24
 f50:	01 c0       	rjmp	.+2      	; 0xf54 <memset+0x6>
 f52:	6d 93       	st	X+, r22
 f54:	41 50       	subi	r20, 0x01	; 1
 f56:	50 40       	sbci	r21, 0x00	; 0
 f58:	e0 f7       	brcc	.-8      	; 0xf52 <memset+0x4>
 f5a:	08 95       	ret

00000f5c <strncpy>:
 f5c:	fb 01       	movw	r30, r22
 f5e:	dc 01       	movw	r26, r24
 f60:	41 50       	subi	r20, 0x01	; 1
 f62:	50 40       	sbci	r21, 0x00	; 0
 f64:	48 f0       	brcs	.+18     	; 0xf78 <strncpy+0x1c>
 f66:	01 90       	ld	r0, Z+
 f68:	0d 92       	st	X+, r0
 f6a:	00 20       	and	r0, r0
 f6c:	c9 f7       	brne	.-14     	; 0xf60 <strncpy+0x4>
 f6e:	01 c0       	rjmp	.+2      	; 0xf72 <strncpy+0x16>
 f70:	1d 92       	st	X+, r1
 f72:	41 50       	subi	r20, 0x01	; 1
 f74:	50 40       	sbci	r21, 0x00	; 0
 f76:	e0 f7       	brcc	.-8      	; 0xf70 <strncpy+0x14>
 f78:	08 95       	ret

00000f7a <_exit>:
 f7a:	f8 94       	cli

00000f7c <__stop_program>:
 f7c:	ff cf       	rjmp	.-2      	; 0xf7c <__stop_program>
